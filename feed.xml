<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="pt"><generator uri="https://jekyllrb.com/" version="4.4.1">Jekyll</generator><link href="https://pfransozi.github.io/feed.xml" rel="self" type="application/atom+xml"/><link href="https://pfransozi.github.io/" rel="alternate" type="text/html" hreflang="pt"/><updated>2025-12-01T16:47:08+00:00</updated><id>https://pfransozi.github.io/feed.xml</id><title type="html">Philipe Fransozi</title><subtitle>Pesquisador em cibersegurança (Android malware + IA/ML) e professor de programação Web &amp; Python. </subtitle><entry><title type="html">PATH hijacking no Linux: sudo, PATH e root</title><link href="https://pfransozi.github.io/blog/2025/tryhackme-path-hijacking/" rel="alternate" type="text/html" title="PATH hijacking no Linux: sudo, PATH e root"/><published>2025-11-30T00:00:00+00:00</published><updated>2025-11-30T00:00:00+00:00</updated><id>https://pfransozi.github.io/blog/2025/tryhackme-path-hijacking</id><content type="html" xml:base="https://pfransozi.github.io/blog/2025/tryhackme-path-hijacking/"><![CDATA[<h2 id="introdução">Introdução</h2> <p>Recentemente eu fiz o lab <strong>Eavesdropper – Find the Flag</strong>, no TryHackMe. À primeira vista, parecia “só mais um” desafio de escalonamento de privilégios em Linux. Na prática, ele acabou virando uma aula muito concreta sobre:</p> <ul> <li>Como o <code class="language-plaintext highlighter-rouge">PATH</code> pode ser abusado para rodar binários falsos.</li> <li>Como isso se conecta ao <code class="language-plaintext highlighter-rouge">sudo</code>.</li> <li>E, mais importante: como evitar esse tipo de ataque em ambientes de produção.</li> </ul> <p>Neste post vou contar rapidamente como funciona o ataque (sem código malicioso passo a passo) e, principalmente, quais são as boas práticas para se proteger desse tipo de vetor.</p> <hr/> <h2 id="cenário-do-lab-versão-resumida">Cenário do lab (versão resumida)</h2> <p>No lab, eu tinha acesso SSH como um usuário comum, <code class="language-plaintext highlighter-rouge">frank</code>. O objetivo era, claro, virar <code class="language-plaintext highlighter-rouge">root</code>. Passos principais que fiz:</p> <ol> <li>Usei uma ferramenta de monitoramento de processos (<code class="language-plaintext highlighter-rouge">pspy</code>) para observar o que o sistema estava executando em background.</li> <li>Em determinado momento aparecia algo como:</li> </ol> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">UID</span><span class="o">=</span>0 | <span class="nb">sudo cat</span> /etc/shadow
</code></pre></div></div> <p>Ou seja: algum processo estava chamando <code class="language-plaintext highlighter-rouge">sudo</code> para ler <code class="language-plaintext highlighter-rouge">/etc/shadow</code>.</p> <p>A partir daí, a ideia do lab era: se alguém está chamando <code class="language-plaintext highlighter-rouge">sudo</code> em um contexto onde o ambiente do usuário conta, dá pra enganar o sistema fazendo <code class="language-plaintext highlighter-rouge">sudo</code> apontar para outra coisa. Isso nos leva ao coração do ataque: PATH hijacking.</p> <h2 id="entendendo-o-path-hijacking">Entendendo o PATH hijacking</h2> <p>No Linux, quando você digita um comando como:</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="nb">sudo id</span>
</code></pre></div></div> <p>O shell não “nasce sabendo” onde está <code class="language-plaintext highlighter-rouge">sudo</code>. Ele procura o binário percorrendo os diretórios definidos na variável de ambiente <code class="language-plaintext highlighter-rouge">PATH</code>, na ordem:</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="nb">echo</span> <span class="nv">$PATH</span>
    <span class="c"># Exemplo típico:</span>
    /usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:...
</code></pre></div></div> <p>A lógica é:</p> <ol> <li>Procura sudo em <code class="language-plaintext highlighter-rouge">/usr/local/sbin</code>.</li> <li>Se não achar, tenta <code class="language-plaintext highlighter-rouge">/usr/local/bin</code>.</li> <li>Depois <code class="language-plaintext highlighter-rouge">/usr/sbin</code>.</li> <li>Depois <code class="language-plaintext highlighter-rouge">/usr/bin</code>.</li> </ol> <p>E assim por diante. Se eu conseguir colocar um diretório escrevível por mim (como <code class="language-plaintext highlighter-rouge">/tmp</code> ou <code class="language-plaintext highlighter-rouge">~/bin</code>) no início do PATH, e criar um arquivo executável chamado sudo ali dentro, o shell passa a encontrar o meu sudo falso antes do <code class="language-plaintext highlighter-rouge">/usr/bin/sudo</code> legítimo. Exemplo conceitual:</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># (conceito) Colocar /tmp no começo do PATH</span>
<span class="nb">export </span><span class="nv">PATH</span><span class="o">=</span>/tmp:<span class="nv">$PATH</span>
<span class="c"># Agora, se existir /tmp/sudo e ele for executável:</span>
which <span class="nb">sudo</span>
<span class="c"># /tmp/sudo</span>
</code></pre></div></div> <p>Isso é PATH hijacking. No lab, o “pulo do gato” foi justamente: ajustar o <code class="language-plaintext highlighter-rouge">PATH</code> no arquivo <code class="language-plaintext highlighter-rouge">~/.bashrc</code>. Isso era preciso porque o “gatilho” do comando <code class="language-plaintext highlighter-rouge">sudo /etc/shadow</code> era no momento do login. E foi preciso garantir que a linha estivesse no fim do arquivo <code class="language-plaintext highlighter-rouge">~/.bashrc</code> e viesse antes do PATH original. Assim, toda nova sessão <code class="language-plaintext highlighter-rouge">bash</code> do usuário já nascia com <code class="language-plaintext highlighter-rouge">/tmp</code> na frente – e qualquer <code class="language-plaintext highlighter-rouge">sudo</code> digitado naquela sessão cairia no binário falso.</p> <h2 id="onde-isso-vira-ataque-de-verdade">Onde isso vira ataque de verdade?</h2> <p>Se eu consigo:</p> <ol> <li>Fazer o usuário (ou algum script) executar sudo sem caminho absoluto (apenas <code class="language-plaintext highlighter-rouge">sudo</code>, não <code class="language-plaintext highlighter-rouge">/usr/bin/sudo</code>).</li> <li>Num contexto onde o <code class="language-plaintext highlighter-rouge">PATH</code> é controlável.</li> <li>E colocar um binário/script falso chamado <code class="language-plaintext highlighter-rouge">sudo</code> à frente do <code class="language-plaintext highlighter-rouge">/usr/bin</code>.</li> </ol> <p>Então eu posso:</p> <ol> <li>Executar qualquer coisa no lugar do <code class="language-plaintext highlighter-rouge">sudo</code> real.</li> <li>E potencialmente roubar credenciais (por exemplo, pedindo a senha e guardando em algum lugar antes de repassar para o <code class="language-plaintext highlighter-rouge">/usr/bin/sudo</code> verdadeiro).</li> </ol> <p>Essa é a parte que, em ambiente real, vira uma técnica de <strong>Credential Access</strong> / <strong>Privilege Escalation</strong>. No lab, o objetivo era justamente explorar esse comportamento para capturar a senha e escalar para <code class="language-plaintext highlighter-rouge">root</code>. Em ambiente de produção, esse mesmo padrão é um incidente de segurança grave.</p> <p>No caso específico no lab, o mais curioso é que <strong>não era um usuário humano digitando <code class="language-plaintext highlighter-rouge">sudo</code> e a senha no terminal</strong>. Quem estava rodando <code class="language-plaintext highlighter-rouge">sudo cat /etc/shadow</code> era <strong>um serviço/script automatizado</strong>, em background, em um contexto de maior privilégio.</p> <p>Ou seja:</p> <ul> <li>Um processo legítimo chamava <code class="language-plaintext highlighter-rouge">sudo</code> sem caminho absoluto (<code class="language-plaintext highlighter-rouge">sudo ...</code>, e não <code class="language-plaintext highlighter-rouge">/usr/bin/sudo ...</code>).</li> <li>Esse processo rodava com privilégios elevados ou com regras de <code class="language-plaintext highlighter-rouge">sudo</code> permissivas.</li> <li>O meu <code class="language-plaintext highlighter-rouge">sudo</code> falso, em <code class="language-plaintext highlighter-rouge">/tmp</code>, era encontrado primeiro por causa do <code class="language-plaintext highlighter-rouge">PATH</code>.</li> </ul> <p>Em muitos exemplos de PATH hijacking a narrativa é “roubei a senha que o usuário digitou no prompt do sudo”. Neste lab, o cenário é mais sutil (e mais próximo de ambientes reais):</p> <ul> <li>É um <strong>serviço de sistema</strong>, com um fluxo automatizado.</li> <li>Que chama <code class="language-plaintext highlighter-rouge">sudo</code> como parte de uma rotina de iníco de sessão.</li> <li>E acaba sendo desviado para um binário malicioso por causa do <code class="language-plaintext highlighter-rouge">PATH</code>.</li> </ul> <p>O impacto é o mesmo (ou até pior): <strong>execução de código no contexto do serviço</strong>, potencialmente com privilégios altos, sem depender de nenhuma interação do usuário na frente do teclado.</p> <h2 id="conectando-com-o-mitre-attck">Conectando com o MITRE ATT&amp;CK</h2> <p>Se olharmos esse lab com a lente do MITRE ATT&amp;CK, dá pra mapear bem o que está acontecendo e, principalmente, o papel das automações que abusam de sudo, não só do usuário na frente do terminal.</p> <p>Táticas envolvidas:</p> <ul> <li><strong>Privilege Escalation</strong> (TA0004) – sair de usuário comum (<code class="language-plaintext highlighter-rouge">frank</code>) para <code class="language-plaintext highlighter-rouge">root</code>.</li> <li><strong>Credential Access</strong> (TA0006) – porque o alvo intermediário é ler <code class="language-plaintext highlighter-rouge">/etc/shadow</code> e potencialmente quebrar senhas depois.</li> </ul> <h3 id="path-hijacking-t1574007--path-interception-by-path-environment-variable"><code class="language-plaintext highlighter-rouge">PATH</code> hijacking (T1574.007): <code class="language-plaintext highlighter-rouge">Path</code> Interception by <code class="language-plaintext highlighter-rouge">PATH</code> Environment Variable</h3> <p>A técnica de colocar <code class="language-plaintext highlighter-rouge">/tmp</code> na frente do <code class="language-plaintext highlighter-rouge">PATH</code> e criar um <code class="language-plaintext highlighter-rouge">sudo</code> falso se encaixa em:</p> <div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>T1574.007 – Hijack Execution Flow: Path Interception by PATH Environment Variable
</code></pre></div></div> <p>Pontos em comum:</p> <ul> <li>Manipular a variável PATH.</li> <li>Colocar um binário malicioso antes do binário legítimo.</li> <li>Deixar o sistema chamar o executável “errado” quando alguém digita um comando sem caminho absoluto.</li> </ul> <p>No lab, isso acontece quando:</p> <ul> <li>Adiciono <code class="language-plaintext highlighter-rouge">export PATH=/tmp:$PATH</code> no arquivo do <code class="language-plaintext highlighter-rouge">~/.bashrc</code>, que será carregado em cada nova sessão.</li> <li>Crio um <code class="language-plaintext highlighter-rouge">/tmp/sudo</code> malicioso.</li> <li>Deixo que um processo automatizado rode <code class="language-plaintext highlighter-rouge">sudo</code> sem especificar <code class="language-plaintext highlighter-rouge">/usr/bin/sudo</code>.</li> </ul> <p>Aqui o ponto não é só “enganar o usuário”, mas enganar o próprio serviço: o fluxo de execução do serviço é sequestrado via PATH hijacking.</p> <h3 id="abuso-do-sudo--t1548003--sudo-and-sudo-caching">Abuso do <code class="language-plaintext highlighter-rouge">sudo</code> → T1548.003 – Sudo and Sudo Caching</h3> <p>A outra peça é o uso (ou abuso) do <code class="language-plaintext highlighter-rouge">sudo</code> como mecanismo de elevação de privilégio dentro de scripts/serviços:</p> <div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>T1548.003 – Abuse Elevation Control Mechanism: Sudo and Sudo Caching
</code></pre></div></div> <p>No fluxo do lab:</p> <ul> <li>Um processo legítimo chama <code class="language-plaintext highlighter-rouge">sudo cat /etc/shadow</code>.</li> <li>Eu interfiro nesse fluxo com um <code class="language-plaintext highlighter-rouge">sudo</code> falso.</li> <li>A automação confia que <code class="language-plaintext highlighter-rouge">sudo</code> é o binário legítimo e que o ambiente está “limpo”.</li> <li>A partir daí, eu executo o que quiser no contexto daquele serviço (e/ou uso a credencial para obter root).</li> </ul> <p>Esse é exatamente o tipo de cenário descrito no ATT&amp;CK quando fala de:</p> <ul> <li>Scripts e jobs que dependem de sudo para subir privilégio.</li> <li>Regras de <code class="language-plaintext highlighter-rouge">sudoers</code> permissivas (<code class="language-plaintext highlighter-rouge">NOPASSWD</code>, comandos muito amplos).</li> <li>Cadeias de automação que confiam demais em <code class="language-plaintext highlighter-rouge">sudo</code> sem controlar ambiente e caminhos.</li> </ul> <h3 id="leitura-de-etcshadow--t1003008--etcpasswd-and-etcshadow">Leitura de /etc/shadow → T1003.008 – /etc/passwd and /etc/shadow</h3> <p>O comando visto no pspy não é qualquer coisa, é:</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo cat</span> /etc/shadow
</code></pre></div></div> <p>Isso entra em:</p> <div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>T1003.008 – OS Credential Dumping: /etc/passwd and /etc/shadow
</code></pre></div></div> <p>O objetivo clássico:</p> <ul> <li>Ler <code class="language-plaintext highlighter-rouge">/etc/passwd</code> e <code class="language-plaintext highlighter-rouge">/etc/shadow</code>.</li> <li>Fazer dump de hashes de senha.</li> <li>Permitir quebra offline com ferramentas como John the Ripper ou Hashcat.</li> </ul> <p>No lab, eu uso isso como parte de um cenário de escalonamento de privilégios. Na vida real, isso vira ponto de partida para:</p> <ul> <li>Account takeover.</li> <li>Movimento lateral.</li> <li>Criação de novas contas com privilégios elevados.</li> </ul> <h3 id="por-que-isso-importa-pra-defesa">Por que isso importa pra defesa?</h3> <p>Olhar para o lab via MITRE ATT&amp;CK ajuda a transformar: “Ganhei root e peguei a flag” em:</p> <ul> <li>Técnicas mapeadas, com nomes e IDs.</li> <li>Pontos de detecção (onde você liga alertas).</li> <li>Pontos de mitigação (onde você faz hardening).</li> </ul> <p>Por exemplo:</p> <ul> <li>Para T1574.007 (<code class="language-plaintext highlighter-rouge">PATH</code> hijack): <ul> <li>Monitorar alterações suspeitas em <code class="language-plaintext highlighter-rouge">PATH</code>.</li> <li>Monitorar criação de binários como <code class="language-plaintext highlighter-rouge">sudo</code>, <code class="language-plaintext highlighter-rouge">ssh</code>, <code class="language-plaintext highlighter-rouge">passwd</code> em diretórios de usuário ou em <code class="language-plaintext highlighter-rouge">/tmp</code>.</li> </ul> </li> <li>Para T1548.003 (<code class="language-plaintext highlighter-rouge">sudo</code> abuse) <ul> <li>Auditar o <code class="language-plaintext highlighter-rouge">/etc/sudoers</code>.</li> <li>Reduzir comandos liberados via <code class="language-plaintext highlighter-rouge">sudo</code>.</li> <li>Registrar comandos <code class="language-plaintext highlighter-rouge">sudo</code> junto com usuário, TTY, host.</li> </ul> </li> <li>Para T1003.008 ({ }) <ul> <li>Alertar sempre que <code class="language-plaintext highlighter-rouge">/etc/shadow</code> for acessado fora de contextos esperados</li> <li>Usar auditd/EDR para ver quem está lendo esse arquivo e como.</li> </ul> </li> </ul> <h2 id="como-impedir-isso-em-ambientes-de-produção">Como impedir isso em ambientes de produção</h2> <h3 id="nunca-coloque-diretórios-escrevíveis-no-path-tipo-tmp">Nunca coloque diretórios escrevíveis no <code class="language-plaintext highlighter-rouge">PATH</code> (tipo <code class="language-plaintext highlighter-rouge">/tmp</code>)</h3> <p>Isso vale tanto para usuários comuns quanto, principalmente, para <code class="language-plaintext highlighter-rouge">root</code>.</p> <ul> <li>Nunca deixe <code class="language-plaintext highlighter-rouge">/tmp</code>, <code class="language-plaintext highlighter-rouge">/var/tmp</code> ou qualquer diretório globalmente escrevível (<code class="language-plaintext highlighter-rouge">drwxrwxrwt</code>) no <code class="language-plaintext highlighter-rouge">PATH</code>.</li> <li>Evite também colocar diretórios do usuário (<code class="language-plaintext highlighter-rouge">~/bin</code>, <code class="language-plaintext highlighter-rouge">~/.local/bin</code>) no <code class="language-plaintext highlighter-rouge">PATH</code> do <code class="language-plaintext highlighter-rouge">root</code>.</li> </ul> <p>Se algum script fizer isso, o risco de PATH hijack sobe muito: qualquer usuário que tiver permissão de escrita ali pode “injetar” binários falsos.</p> <h3 id="em-scripts-privilegiados-use-caminhos-absolutos">Em scripts privilegiados, use caminhos absolutos</h3> <p>Em scripts que rodam como <code class="language-plaintext highlighter-rouge">root</code> (<code class="language-plaintext highlighter-rouge">cron</code>, <code class="language-plaintext highlighter-rouge">systemd</code>, scripts de provisionamento etc.), não confie no <code class="language-plaintext highlighter-rouge">PATH</code>. Use sempre caminhos absolutos:</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># Em vez de:</span>
<span class="nb">sudo cat</span> /etc/shadow
service ssh status
</code></pre></div></div> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># Use:</span>
/usr/bin/sudo /bin/cat /etc/shadow
/usr/sbin/service ssh status
</code></pre></div></div> <p>Isso elimina a possibilidade de PATH hijack nesses pontos: mesmo que alguém consiga mexer no <code class="language-plaintext highlighter-rouge">PATH</code>, o comando chamado será o específico <code class="language-plaintext highlighter-rouge">/usr/bin/sudo</code>, e não “qualquer coisa chamada sudo”.</p> <h3 id="hardening-do-sudoers-e-usar-secure_path">Hardening do sudoers (e usar secure_path)</h3> <p>No <code class="language-plaintext highlighter-rouge">/etc/sudoers</code>, existe a opção <code class="language-plaintext highlighter-rouge">secure_path</code> que define um <code class="language-plaintext highlighter-rouge">PATH</code> “forçado” para comandos executados via <code class="language-plaintext highlighter-rouge">sudo</code>, por exemplo:</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Defaults <span class="nv">secure_path</span><span class="o">=</span><span class="s2">"/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin"</span>
</code></pre></div></div> <p>Isso faz com que, quando alguém roda <code class="language-plaintext highlighter-rouge">sudo</code> comando, o <code class="language-plaintext highlighter-rouge">PATH</code> usado seja um conjunto de caminhos “limpos”, ignorando <code class="language-plaintext highlighter-rouge">PATH</code> adulterados no ambiente do usuário.</p> <p>Outras boas práticas no sudoers:</p> <ul> <li>Limitar o uso de NOPASSWD só ao estritamente necessário.</li> <li>Evitar comandos genéricos demais (tipo ALL).</li> <li>Revisar regularmente quem pode usar sudo e para quê.</li> </ul> <h3 id="monitorar-scripts-de-login-e-variáveis-de-ambiente">Monitorar scripts de login e variáveis de ambiente</h3> <p>Pontos a revisar periodicamente:</p> <p>Arquivos globais:</p> <ul> <li><code class="language-plaintext highlighter-rouge">/etc/profile</code>.</li> <li><code class="language-plaintext highlighter-rouge">/etc/bash.bashrc</code>.</li> <li><code class="language-plaintext highlighter-rouge">/etc/zprofile</code>, <code class="language-plaintext highlighter-rouge">/etc/zshrc</code> (se usar zsh).</li> </ul> <p>Arquivos por usuário:</p> <ul> <li><code class="language-plaintext highlighter-rouge">~/.profile</code>.</li> <li><code class="language-plaintext highlighter-rouge">~/.bash_profile</code>.</li> <li><code class="language-plaintext highlighter-rouge">~/.bashrc</code>.</li> <li><code class="language-plaintext highlighter-rouge">~/.zshrc</code>.</li> </ul> <p>Procure por:</p> <ul> <li>Linhas que alterem <code class="language-plaintext highlighter-rouge">PATH</code> de forma suspeita (<code class="language-plaintext highlighter-rouge">PATH=...</code>, <code class="language-plaintext highlighter-rouge">export PATH=...</code>).</li> <li>Inclusão de diretórios incomuns no começo do <code class="language-plaintext highlighter-rouge">PATH</code>.</li> <li>Comandos que modifiquem <code class="language-plaintext highlighter-rouge">PATH</code> de forma dinâmica</li> </ul> <p>Ferramentas de integridade (tipo AIDE, Tripwire) também podem ajudar a detectar mudanças inesperadas nesses arquivos.</p> <h3 id="auditar-binários-em-diretórios-estranhos">Auditar binários em diretórios “estranhos”</h3> <p>De tempos em tempos, é útil varrer:</p> <ul> <li><code class="language-plaintext highlighter-rouge">/tmp</code>.</li> <li><code class="language-plaintext highlighter-rouge">/var/tmp</code>.</li> <li>Diretórios como <code class="language-plaintext highlighter-rouge">~/bin</code>, <code class="language-plaintext highlighter-rouge">~/.local/bin</code>.</li> </ul> <p>Em busca de:</p> <ul> <li>Arquivos executáveis com nomes “sensíveis”: <code class="language-plaintext highlighter-rouge">sudo</code>, <code class="language-plaintext highlighter-rouge">ssh</code>, <code class="language-plaintext highlighter-rouge">passwd</code>, <code class="language-plaintext highlighter-rouge">login</code>, entre outros.</li> <li>Scripts com conteúdo suspeito (captura de senha, logs estranhos, exfiltração).</li> </ul> <p>Alguns comandos simples, já ajudam a pegar coisas óbvias:</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>find /tmp  <span class="nt">-maxdepth</span> 2 <span class="nt">-type</span> f <span class="nt">-perm</span> <span class="nt">-111</span>
</code></pre></div></div> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>find /home <span class="nt">-maxdepth</span> 3 <span class="nt">-type</span> f <span class="nt">-perm</span> <span class="nt">-111</span> <span class="nt">-name</span> <span class="s1">'sudo'</span>
</code></pre></div></div> <h3 id="usar-ferramentas-tipo-pspy-também-no-blue-team">Usar ferramentas tipo pspy também no Blue Team</h3> <p>No lab, eu usei pspy para enxergar processos e encontrar oportunidades de ataque. Mas a mesma ideia funciona ao contrário:</p> <p>Em uma investigação forense ou um hunting pontual, rodar algo no estilo pspy ajuda a identificar:</p> <ul> <li>scripts inesperados</li> <li>comandos <code class="language-plaintext highlighter-rouge">sudo</code> rodando em horários estranhos</li> <li>processos acessando <code class="language-plaintext highlighter-rouge">/etc/shadow</code>, <code class="language-plaintext highlighter-rouge">/etc/passwd</code> ou outros arquivos sensíveis</li> </ul> <p>Claro: em produção, isso precisa ser feito com cuidado (carga, privacidade etc.), mas a ideia é válida.</p> <h3 id="checklist-rápido-de-hardening-para-automações-com-sudo">Checklist rápido de hardening para automações com sudo</h3> <p>Se você tem cron, systemd, scripts de manutenção, pipelines de CI/CD ou qualquer automação que roda com privilégios, vale passar por esse checklist:</p> <ol> <li>Seu script realmente precisa de <code class="language-plaintext highlighter-rouge">sudo</code>? <ul> <li>Sempre que possível: <ul> <li>Execute o script diretamente como <code class="language-plaintext highlighter-rouge">root</code> (via systemd com User=/Group= bem definidos).</li> <li>Ou separe a parte privilegiada em um serviço dedicado, em vez de sair espalhando <code class="language-plaintext highlighter-rouge">sudo</code> dentro de scripts.</li> </ul> </li> <li>Regra de bolso: “<code class="language-plaintext highlighter-rouge">sudo</code> é interface pra humano, não pra script”. Se o script precisa de <code class="language-plaintext highlighter-rouge">root</code>, pense em rodá-lo no contexto certo desde o início.</li> </ul> </li> <li>Se precisar usar sudo, use caminho absoluto: <ul> <li> <p>Dentro de scripts:</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="c"># Evite:</span>
  <span class="nb">sudo </span>comando
  <span class="nb">sudo cat</span> /etc/shadow
</code></pre></div> </div> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="c"># Prefira:</span>
  /usr/bin/sudo /bin/comando
  /usr/bin/sudo /bin/cat /etc/shadow
</code></pre></div> </div> <p>Mesma lógica para os binários chamados pelo sudo (<code class="language-plaintext highlighter-rouge">/bin/cat</code>, <code class="language-plaintext highlighter-rouge">/usr/sbin/service</code>).</p> </li> </ul> </li> <li>Trate o <code class="language-plaintext highlighter-rouge">PATH</code> como superfície de ataque: <ul> <li> <p>Em scripts privilegiados, defina um PATH mínimo, controlado:</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="nv">PATH</span><span class="o">=</span><span class="s2">"/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin"</span>
  <span class="nb">export </span>PATH
</code></pre></div> </div> </li> <li>Não herde PATH do ambiente do usuário sem pensar.</li> <li>Nunca inclua diretórios escrevíveis por usuários (<code class="language-plaintext highlighter-rouge">/tmp</code>, <code class="language-plaintext highlighter-rouge">/var/tmp</code>, diretórios de home) no <code class="language-plaintext highlighter-rouge">PATH</code> de automações privilegiadas.</li> </ul> </li> <li>Revise o sudoers pensando em automações: <ul> <li>Use visudo e confira: <ul> <li>Regras com NOPASSWD: são realmente necessárias? Podem ser mais específicas?</li> <li> <p>Comandos permitidos: evite ALL, prefira linhas do tipo:</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  meu-user <span class="nv">ALL</span><span class="o">=(</span>root<span class="o">)</span> NOPASSWD: /usr/bin/systemctl restart meu-servico
</code></pre></div> </div> </li> </ul> </li> <li>Avalie se o serviço não deveria rodar como root direto, em vez de usar sudo por baixo do pano.</li> <li> <p>Ative e use <code class="language-plaintext highlighter-rouge">secure_path</code> no sudoers:</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  Defaults <span class="nv">secure_path</span><span class="o">=</span><span class="s2">"/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin"</span>
</code></pre></div> </div> </li> </ul> <p>Assim, mesmo quando scripts chamam sudo, o comando rodará com um PATH limpo.</p> </li> </ol> <h2 id="conclusão">Conclusão</h2> <p>No fim das contas, esse lab não foi só sobre “pegar root”. Ele funcionou quase como um raio-x de algo que a gente costuma ignorar: detalhes de ambiente, <code class="language-plaintext highlighter-rouge">PATH</code> solto demais, <code class="language-plaintext highlighter-rouge">sudo</code> em automações e aquele “depois eu arrumo” que vai ficando pra depois.</p> <p>O cenário é bem simples: um usuário comum, um serviço rodando em segundo plano, um <code class="language-plaintext highlighter-rouge">sudo</code> sem caminho absoluto e um <code class="language-plaintext highlighter-rouge">PATH</code> ajustado no lugar “certo”. Nada de exploit mirabolante, nada de zero-day — só a combinação de conveniência + descuido.</p> <p>A moral da história não é “nunca use sudo” ou “automatização é ruim”, mas sim:</p> <ul> <li>se o seu script precisa mesmo de privilégio, dê esse privilégio de forma explícita e controlada;</li> <li>trate <code class="language-plaintext highlighter-rouge">PATH</code>, <code class="language-plaintext highlighter-rouge">sudoers</code> e scripts de login como superfície de ataque, não só como “configuração de conforto”.</li> </ul>]]></content><author><name></name></author><category term="cibersegurança"/><category term="linux"/><category term="lab-thm"/><category term="linux"/><category term="privilege-escalation"/><category term="sudo"/><category term="path-hijacking"/><category term="mitre-attck"/><summary type="html"><![CDATA[Um resumo de como um simples PATH hijacking no Linux pode render acesso root e como evitar esse tipo de falha em ambientes de produção.]]></summary></entry></feed>