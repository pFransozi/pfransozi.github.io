<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="pt"><generator uri="https://jekyllrb.com/" version="4.4.1">Jekyll</generator><link href="https://pfransozi.github.io/feed.xml" rel="self" type="application/atom+xml"/><link href="https://pfransozi.github.io/" rel="alternate" type="text/html" hreflang="pt"/><updated>2025-12-01T18:53:14+00:00</updated><id>https://pfransozi.github.io/feed.xml</id><title type="html">Philipe Fransozi</title><subtitle>Pesquisador em cibersegurança (Android malware + IA/ML) e professor de programação Web &amp; Python. </subtitle><entry><title type="html">PATH hijacking no Linux: sudo, PATH e root</title><link href="https://pfransozi.github.io/blog/2025/tryhackme-path-hijacking/" rel="alternate" type="text/html" title="PATH hijacking no Linux: sudo, PATH e root"/><published>2025-11-30T00:00:00+00:00</published><updated>2025-11-30T00:00:00+00:00</updated><id>https://pfransozi.github.io/blog/2025/tryhackme-path-hijacking</id><content type="html" xml:base="https://pfransozi.github.io/blog/2025/tryhackme-path-hijacking/"><![CDATA[<h2 id="introdução">Introdução</h2> <p>Recentemente eu fiz o lab <strong>Eavesdropper – Find the Flag</strong>, no TryHackMe. À primeira vista, parecia “só mais um” desafio de escalonamento de privilégios em Linux. Na prática, ele acabou virando uma aula muito concreta sobre:</p> <ul> <li>Como o <code class="language-plaintext highlighter-rouge">PATH</code> pode ser abusado para rodar binários falsos.</li> <li>Como isso se conecta ao <code class="language-plaintext highlighter-rouge">sudo</code>.</li> <li>E, mais importante, como evitar esse tipo de ataque em ambientes de produção.</li> </ul> <p>Neste post vou contar rapidamente como funciona o ataque (sem código malicioso passo a passo) e, principalmente, quais são as boas práticas para se proteger desse tipo de vetor.</p> <hr/> <h3 id="para-quem-é-este-post">Para quem é este post?</h3> <ul> <li><strong>Nível:</strong> intermediário em Linux.</li> <li><strong>Pré-requisitos:</strong> <ul> <li>Saber navegar no terminal (<code class="language-plaintext highlighter-rouge">cd</code>, <code class="language-plaintext highlighter-rouge">ls</code>, etc.) e usar <code class="language-plaintext highlighter-rouge">sudo</code> no dia a dia.</li> <li>Entender a diferença entre usuário comum e <code class="language-plaintext highlighter-rouge">root</code>.</li> <li>Já ter ouvido falar em <code class="language-plaintext highlighter-rouge">/etc/passwd</code> e <code class="language-plaintext highlighter-rouge">/etc/shadow</code>.</li> </ul> </li> </ul> <hr/> <h2 id="cenário-do-lab-versão-resumida">Cenário do lab (versão resumida)</h2> <p>No lab, eu tinha acesso SSH como um usuário comum, <code class="language-plaintext highlighter-rouge">frank</code>. O objetivo era, claro, virar <code class="language-plaintext highlighter-rouge">root</code>. Os passos principais:</p> <ol> <li>Usei uma ferramenta de monitoramento de processos (<code class="language-plaintext highlighter-rouge">pspy</code>) para observar o que o sistema estava executando em background.</li> <li> <p>Em determinado momento aparecia algo como:</p> <div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>UID=0 | sudo cat /etc/shadow
</code></pre></div> </div> </li> </ol> <p>Ou seja: <strong>algum processo estava chamando <code class="language-plaintext highlighter-rouge">sudo</code> para ler <code class="language-plaintext highlighter-rouge">/etc/shadow</code></strong>.</p> <p>A partir daí, a ideia do lab era: se alguém está chamando <code class="language-plaintext highlighter-rouge">sudo</code> em um contexto onde o ambiente do usuário conta, dá pra enganar o sistema fazendo <code class="language-plaintext highlighter-rouge">sudo</code> apontar para outra coisa. Isso nos leva ao coração do ataque: <strong>PATH hijacking</strong>.</p> <h2 id="entendendo-o-path-hijacking">Entendendo o PATH hijacking</h2> <p>No Linux, quando você digita um comando como:</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo id</span>
</code></pre></div></div> <p>o shell não “nasce sabendo” onde está <code class="language-plaintext highlighter-rouge">sudo</code>. Ele procura o binário percorrendo os diretórios definidos na variável de ambiente <code class="language-plaintext highlighter-rouge">PATH</code>, na ordem:</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">echo</span> <span class="nv">$PATH</span>
<span class="c"># Exemplo típico:</span>
<span class="c"># /usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:...</span>
</code></pre></div></div> <p>A lógica é:</p> <ol> <li>Procura <code class="language-plaintext highlighter-rouge">sudo</code> em <code class="language-plaintext highlighter-rouge">/usr/local/sbin</code>.</li> <li>Se não achar, tenta <code class="language-plaintext highlighter-rouge">/usr/local/bin</code>.</li> <li>Depois <code class="language-plaintext highlighter-rouge">/usr/sbin</code>.</li> <li>Depois <code class="language-plaintext highlighter-rouge">/usr/bin</code>.</li> <li>E assim por diante.</li> </ol> <p>Se eu conseguir colocar um diretório <strong>escrevível por mim</strong> (como <code class="language-plaintext highlighter-rouge">/tmp</code> ou <code class="language-plaintext highlighter-rouge">~/bin</code>) <strong>no início do PATH</strong>, e criar um arquivo executável chamado <code class="language-plaintext highlighter-rouge">sudo</code> ali dentro, o shell passa a encontrar o <strong>meu <code class="language-plaintext highlighter-rouge">sudo</code> falso</strong> antes do <code class="language-plaintext highlighter-rouge">/usr/bin/sudo</code> legítimo. Exemplo conceitual:</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># (conceito) Colocar /tmp no começo do PATH</span>
<span class="nb">export </span><span class="nv">PATH</span><span class="o">=</span>/tmp:<span class="nv">$PATH</span>

<span class="c"># Agora, se existir /tmp/sudo e ele for executável:</span>
which <span class="nb">sudo</span>
<span class="c"># /tmp/sudo</span>
</code></pre></div></div> <p>Isso é <strong>PATH hijacking</strong>.</p> <p>No lab, o “pulo do gato” foi justamente ajustar o <code class="language-plaintext highlighter-rouge">PATH</code> no arquivo <code class="language-plaintext highlighter-rouge">~/.bashrc</code>. Isso era preciso porque o “gatilho” do comando <code class="language-plaintext highlighter-rouge">sudo /etc/shadow</code> era no momento do login. E foi preciso garantir que a linha estivesse no fim do arquivo <code class="language-plaintext highlighter-rouge">~/.bashrc</code> e viesse antes do <code class="language-plaintext highlighter-rouge">PATH</code> original. Assim, toda nova sessão <code class="language-plaintext highlighter-rouge">bash</code> do usuário já nascia com <code class="language-plaintext highlighter-rouge">/tmp</code> na frente – e qualquer <code class="language-plaintext highlighter-rouge">sudo</code> digitado naquela sessão cairia no binário falso.</p> <h3 id="diagrama-rápido-do-fluxo">Diagrama rápido do fluxo</h3> <div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[Fluxo normal]
usuário/serviço -&gt; "sudo" -&gt; /usr/bin/sudo -&gt; /etc/shadow

[Fluxo com PATH hijack]
usuário/serviço -&gt; "sudo" -&gt; /tmp/sudo (malicioso) -&gt; /usr/bin/sudo -&gt; /etc/shadow
</code></pre></div></div> <p>Repare que o alvo final é o mesmo (<code class="language-plaintext highlighter-rouge">/etc/shadow</code>), mas no segundo caso existe uma etapa maliciosa no meio do caminho, que pode:</p> <ul> <li>capturar senha,</li> <li>registrar comandos,</li> <li>ou executar qualquer coisa antes de repassar para o <code class="language-plaintext highlighter-rouge">sudo</code> real.</li> </ul> <h2 id="onde-isso-vira-ataque-de-verdade">Onde isso vira ataque de verdade?</h2> <p>Se eu consigo:</p> <ol> <li>Fazer o usuário (ou algum script) executar <code class="language-plaintext highlighter-rouge">sudo</code> <strong>sem caminho absoluto</strong> (apenas <code class="language-plaintext highlighter-rouge">sudo</code>, não <code class="language-plaintext highlighter-rouge">/usr/bin/sudo</code>).</li> <li>Num contexto onde o <code class="language-plaintext highlighter-rouge">PATH</code> é controlável.</li> <li>E colocar um binário/script falso chamado <code class="language-plaintext highlighter-rouge">sudo</code> <strong>à frente</strong> do <code class="language-plaintext highlighter-rouge">/usr/bin</code>.</li> </ol> <p>Então eu posso:</p> <ol> <li>Executar qualquer coisa no lugar do <code class="language-plaintext highlighter-rouge">sudo</code> real.</li> <li>E potencialmente <strong>roubar credenciais</strong> (por exemplo, pedindo a senha e guardando em algum lugar antes de repassar para o <code class="language-plaintext highlighter-rouge">/usr/bin/sudo</code> verdadeiro).</li> </ol> <p>Essa é a parte que, em ambiente real, vira uma técnica de <strong>Credential Access / Privilege Escalation</strong>. No lab, o objetivo era justamente explorar esse comportamento para capturar a senha e escalar para <code class="language-plaintext highlighter-rouge">root</code>. Em ambiente de produção, esse mesmo padrão é um incidente de segurança grave.</p> <p>No caso específico do lab, o mais curioso é que <strong>não era um usuário humano</strong> digitando <code class="language-plaintext highlighter-rouge">sudo</code> e a senha no terminal. Quem estava rodando <code class="language-plaintext highlighter-rouge">sudo cat /etc/shadow</code> era <strong>um serviço/script automatizado</strong>, em background, em um contexto de maior privilégio.</p> <p>Ou seja:</p> <ul> <li>Um processo legítimo chamava <code class="language-plaintext highlighter-rouge">sudo</code> sem caminho absoluto (<code class="language-plaintext highlighter-rouge">sudo ...</code>, e não <code class="language-plaintext highlighter-rouge">/usr/bin/sudo ...</code>).</li> <li>Esse processo rodava com privilégios elevados ou com regras de <code class="language-plaintext highlighter-rouge">sudo</code> permissivas.</li> <li>O meu <code class="language-plaintext highlighter-rouge">sudo</code> falso, em <code class="language-plaintext highlighter-rouge">/tmp</code>, era encontrado primeiro por causa do <code class="language-plaintext highlighter-rouge">PATH</code>.</li> </ul> <p>Em muitos exemplos de PATH hijacking a narrativa é “roubei a senha que o usuário digitou no prompt do <code class="language-plaintext highlighter-rouge">sudo</code>”. Neste lab, o cenário é mais sutil (e mais próximo de ambientes reais):</p> <ul> <li>É um <strong>serviço de sistema</strong>, com um fluxo automatizado.</li> <li>Que chama <code class="language-plaintext highlighter-rouge">sudo</code> como parte de uma rotina de <strong>início de sessão</strong>.</li> <li>E acaba sendo desviado para um binário malicioso por causa do <code class="language-plaintext highlighter-rouge">PATH</code>.</li> </ul> <p>O impacto é o mesmo (ou até pior): execução de código no contexto do serviço, potencialmente com privilégios altos, <strong>sem depender de nenhuma interação do usuário</strong> na frente do teclado.</p> <h2 id="conectando-com-o-mitre-attck">Conectando com o MITRE ATT&amp;CK</h2> <p>Se olharmos esse lab com a lente do <strong>MITRE ATT&amp;CK</strong>, dá pra mapear bem o que está acontecendo e, principalmente, o papel das automações que abusam de <code class="language-plaintext highlighter-rouge">sudo</code>, não só do usuário na frente do terminal.</p> <p>Táticas envolvidas:</p> <ul> <li><strong>Privilege Escalation (TA0004)</strong> – sair de usuário comum (<code class="language-plaintext highlighter-rouge">frank</code>) para <code class="language-plaintext highlighter-rouge">root</code>.</li> <li><strong>Credential Access (TA0006)</strong> – porque o alvo intermediário é ler <code class="language-plaintext highlighter-rouge">/etc/shadow</code> e potencialmente quebrar senhas depois.</li> </ul> <h3 id="path-hijacking-t1574007-path-interception-by-path-environment-variable">PATH hijacking (T1574.007): Path Interception by PATH Environment Variable</h3> <p>A técnica de colocar <code class="language-plaintext highlighter-rouge">/tmp</code> na frente do <code class="language-plaintext highlighter-rouge">PATH</code> e criar um <code class="language-plaintext highlighter-rouge">sudo</code> falso se encaixa em:</p> <div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>T1574.007 – Hijack Execution Flow: Path Interception by PATH Environment Variable
</code></pre></div></div> <blockquote> <p>Referência oficial:<br/> <a href="https://attack.mitre.org/techniques/T1574/007/">https://attack.mitre.org/techniques/T1574/007/</a></p> </blockquote> <p>Pontos em comum:</p> <ul> <li>Manipular a variável <code class="language-plaintext highlighter-rouge">PATH</code>.</li> <li>Colocar um binário malicioso antes do binário legítimo.</li> <li>Deixar o sistema chamar o executável “errado” quando alguém digita um comando sem caminho absoluto.</li> </ul> <p>No lab, isso acontece quando:</p> <ul> <li>Adiciono <code class="language-plaintext highlighter-rouge">export PATH=/tmp:$PATH</code> no arquivo do <code class="language-plaintext highlighter-rouge">~/.bashrc</code>, que será carregado em cada nova sessão.</li> <li>Crio um <code class="language-plaintext highlighter-rouge">/tmp/sudo</code> malicioso.</li> <li>Deixo que um processo automatizado rode <code class="language-plaintext highlighter-rouge">sudo</code> sem especificar <code class="language-plaintext highlighter-rouge">/usr/bin/sudo</code>.</li> </ul> <p>Aqui o ponto não é só “enganar o usuário”, mas <strong>enganar o próprio serviço</strong>: o fluxo de execução do serviço é sequestrado via PATH hijacking.</p> <h3 id="abuso-do-sudo--t1548003--sudo-and-sudo-caching">Abuso do sudo → T1548.003 – Sudo and Sudo Caching</h3> <p>A outra peça é o uso (ou abuso) do <code class="language-plaintext highlighter-rouge">sudo</code> como mecanismo de elevação de privilégio dentro de scripts/serviços:</p> <div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>T1548.003 – Abuse Elevation Control Mechanism: Sudo and Sudo Caching
</code></pre></div></div> <blockquote> <p>Referência oficial:<br/> <a href="https://attack.mitre.org/techniques/T1548/003/">https://attack.mitre.org/techniques/T1548/003/</a></p> </blockquote> <p>No fluxo do lab:</p> <ul> <li>Um processo legítimo chama <code class="language-plaintext highlighter-rouge">sudo cat /etc/shadow</code>.</li> <li>Eu interfiro nesse fluxo com um <code class="language-plaintext highlighter-rouge">sudo</code> falso.</li> <li>A automação confia que <code class="language-plaintext highlighter-rouge">sudo</code> é o binário legítimo e que o ambiente está “limpo”.</li> <li>A partir daí, eu executo o que quiser no contexto daquele serviço (e/ou uso a credencial para obter <code class="language-plaintext highlighter-rouge">root</code>).</li> </ul> <p>Esse é exatamente o tipo de cenário descrito no ATT&amp;CK quando fala de:</p> <ul> <li>Scripts e jobs que dependem de <code class="language-plaintext highlighter-rouge">sudo</code> para subir privilégio.</li> <li>Regras de <code class="language-plaintext highlighter-rouge">sudoers</code> permissivas (<code class="language-plaintext highlighter-rouge">NOPASSWD</code>, comandos muito amplos).</li> <li>Cadeias de automação que confiam demais em <code class="language-plaintext highlighter-rouge">sudo</code> sem controlar ambiente e caminhos.</li> </ul> <h3 id="leitura-de-etcshadow--t1003008--etcpasswd-and-etcshadow">Leitura de <code class="language-plaintext highlighter-rouge">/etc/shadow</code> → T1003.008 – /etc/passwd and /etc/shadow</h3> <p>O comando visto no <code class="language-plaintext highlighter-rouge">pspy</code> não é qualquer coisa, é:</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo cat</span> /etc/shadow
</code></pre></div></div> <p>Isso entra em:</p> <div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>T1003.008 – OS Credential Dumping: /etc/passwd and /etc/shadow
</code></pre></div></div> <p>Objetivo clássico:</p> <ul> <li>Ler <code class="language-plaintext highlighter-rouge">/etc/passwd</code> e <code class="language-plaintext highlighter-rouge">/etc/shadow</code>;</li> <li>Fazer dump de hashes de senha;</li> <li>Permitir quebra offline com ferramentas como John the Ripper ou Hashcat.</li> </ul> <p>No lab, eu uso isso como parte de um cenário de escalonamento de privilégios. Na vida real, isso vira ponto de partida para:</p> <ul> <li>Account takeover;</li> <li>Movimento lateral;</li> <li>Criação de novas contas com privilégios elevados.</li> </ul> <h3 id="por-que-isso-importa-pra-defesa">Por que isso importa pra defesa?</h3> <p>Olhar para o lab via MITRE ATT&amp;CK ajuda a transformar: “Ganhei root e peguei a flag” em:</p> <ul> <li>Técnicas mapeadas, com nomes e IDs.</li> <li>Pontos de detecção (onde você liga alertas).</li> <li>Pontos de mitigação (onde você faz hardening).</li> </ul> <p>Por exemplo:</p> <ul> <li>Para <strong>T1574.007</strong> (PATH hijack): <ul> <li>Monitorar alterações suspeitas em <code class="language-plaintext highlighter-rouge">PATH</code>;</li> <li>Monitorar criação de binários como <code class="language-plaintext highlighter-rouge">sudo</code>, <code class="language-plaintext highlighter-rouge">ssh</code>, <code class="language-plaintext highlighter-rouge">passwd</code> em diretórios de usuário ou em <code class="language-plaintext highlighter-rouge">/tmp</code>.</li> </ul> </li> <li>Para <strong>T1548.003</strong> (abuso de <code class="language-plaintext highlighter-rouge">sudo</code>): <ul> <li>Auditar o <code class="language-plaintext highlighter-rouge">/etc/sudoers</code>;</li> <li>Reduzir comandos liberados via <code class="language-plaintext highlighter-rouge">sudo</code>;</li> <li>Registrar comandos <code class="language-plaintext highlighter-rouge">sudo</code> junto com usuário, TTY, host.</li> </ul> </li> <li>Para <strong>T1003.008</strong> (<code class="language-plaintext highlighter-rouge">/etc/passwd</code> e <code class="language-plaintext highlighter-rouge">/etc/shadow</code>): <ul> <li>Alertar sempre que <code class="language-plaintext highlighter-rouge">/etc/shadow</code> for acessado fora de contextos esperados;</li> <li>Usar <code class="language-plaintext highlighter-rouge">auditd</code>/EDR para ver quem está lendo esse arquivo e como.</li> </ul> </li> </ul> <h2 id="como-impedir-isso-em-ambientes-de-produção">Como impedir isso em ambientes de produção</h2> <h3 id="nunca-coloque-diretórios-escrevíveis-no-path-tipo-tmp">Nunca coloque diretórios escrevíveis no PATH (tipo <code class="language-plaintext highlighter-rouge">/tmp</code>)</h3> <p>Isso vale tanto para usuários comuns quanto, principalmente, para <code class="language-plaintext highlighter-rouge">root</code>.</p> <ul> <li>Nunca deixe <code class="language-plaintext highlighter-rouge">/tmp</code>, <code class="language-plaintext highlighter-rouge">/var/tmp</code> ou qualquer diretório globalmente escrevível (<code class="language-plaintext highlighter-rouge">drwxrwxrwt</code>) no <code class="language-plaintext highlighter-rouge">PATH</code>.</li> <li>Evite também colocar diretórios do usuário (<code class="language-plaintext highlighter-rouge">~/bin</code>, <code class="language-plaintext highlighter-rouge">~/.local/bin</code>) no <code class="language-plaintext highlighter-rouge">PATH</code> do <code class="language-plaintext highlighter-rouge">root</code>.</li> </ul> <p>Se algum script fizer isso, o risco de PATH hijack sobe muito: qualquer usuário que tiver permissão de escrita ali pode “injetar” binários falsos.</p> <h3 id="em-scripts-privilegiados-use-caminhos-absolutos">Em scripts privilegiados, use caminhos absolutos</h3> <p>Em scripts que rodam como <code class="language-plaintext highlighter-rouge">root</code> (<code class="language-plaintext highlighter-rouge">cron</code>, <code class="language-plaintext highlighter-rouge">systemd</code>, scripts de provisionamento etc.), não confie no <code class="language-plaintext highlighter-rouge">PATH</code>. Use sempre <strong>caminhos absolutos</strong>:</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># Em vez de:</span>
<span class="nb">sudo cat</span> /etc/shadow
service ssh status

<span class="c"># Use:</span>
 /usr/bin/sudo /bin/cat /etc/shadow
 /usr/sbin/service ssh status
</code></pre></div></div> <p>Isso elimina a possibilidade de PATH hijack nesses pontos: mesmo que alguém consiga mexer no <code class="language-plaintext highlighter-rouge">PATH</code>, o comando chamado será o específico <code class="language-plaintext highlighter-rouge">/usr/bin/sudo</code>, e não “qualquer coisa chamada sudo”.</p> <h3 id="hardening-do-sudoers-e-usar-secure_path">Hardening do sudoers (e usar <code class="language-plaintext highlighter-rouge">secure_path</code>)</h3> <p>No <code class="language-plaintext highlighter-rouge">/etc/sudoers</code>, existe a opção <code class="language-plaintext highlighter-rouge">secure_path</code> que define um <code class="language-plaintext highlighter-rouge">PATH</code> “forçado” para comandos executados via <code class="language-plaintext highlighter-rouge">sudo</code>, por exemplo:</p> <div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Defaults secure_path="/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin"
</code></pre></div></div> <p>Isso faz com que, quando alguém roda <code class="language-plaintext highlighter-rouge">sudo comando</code>, o <code class="language-plaintext highlighter-rouge">PATH</code> usado seja um conjunto de caminhos “limpos”, ignorando <code class="language-plaintext highlighter-rouge">PATH</code> adulterados no ambiente do usuário.</p> <p>Outras boas práticas no sudoers:</p> <ul> <li>Limitar o uso de <code class="language-plaintext highlighter-rouge">NOPASSWD</code> só ao estritamente necessário;</li> <li>Evitar comandos genéricos demais (tipo <code class="language-plaintext highlighter-rouge">ALL</code>);</li> <li>Revisar regularmente quem pode usar <code class="language-plaintext highlighter-rouge">sudo</code> e para quê.</li> </ul> <h3 id="monitorar-scripts-de-login-e-variáveis-de-ambiente">Monitorar scripts de login e variáveis de ambiente</h3> <p>Pontos a revisar periodicamente:</p> <p><strong>Arquivos globais:</strong></p> <ul> <li><code class="language-plaintext highlighter-rouge">/etc/profile</code></li> <li><code class="language-plaintext highlighter-rouge">/etc/bash.bashrc</code></li> <li><code class="language-plaintext highlighter-rouge">/etc/zprofile</code>, <code class="language-plaintext highlighter-rouge">/etc/zshrc</code> (se usar zsh)</li> </ul> <p><strong>Arquivos por usuário:</strong></p> <ul> <li><code class="language-plaintext highlighter-rouge">~/.profile</code></li> <li><code class="language-plaintext highlighter-rouge">~/.bash_profile</code></li> <li><code class="language-plaintext highlighter-rouge">~/.bashrc</code></li> <li><code class="language-plaintext highlighter-rouge">~/.zshrc</code></li> </ul> <p>Procure por:</p> <ul> <li>Linhas que alterem <code class="language-plaintext highlighter-rouge">PATH</code> de forma suspeita (<code class="language-plaintext highlighter-rouge">PATH=...</code>, <code class="language-plaintext highlighter-rouge">export PATH=...</code>);</li> <li>Inclusão de diretórios incomuns no começo do <code class="language-plaintext highlighter-rouge">PATH</code>;</li> <li>Comandos que modifiquem <code class="language-plaintext highlighter-rouge">PATH</code> de forma dinâmica.</li> </ul> <p>Ferramentas de integridade (tipo <strong>AIDE</strong> ou <strong>Tripwire</strong>) também podem ajudar a detectar mudanças inesperadas nesses arquivos.</p> <h3 id="auditar-binários-em-diretórios-estranhos">Auditar binários em diretórios “estranhos”</h3> <p>De tempos em tempos, é útil varrer:</p> <ul> <li><code class="language-plaintext highlighter-rouge">/tmp</code></li> <li><code class="language-plaintext highlighter-rouge">/var/tmp</code></li> <li>Diretórios como <code class="language-plaintext highlighter-rouge">~/bin</code>, <code class="language-plaintext highlighter-rouge">~/.local/bin</code></li> </ul> <p>Em busca de:</p> <ul> <li>Arquivos executáveis com nomes “sensíveis”: <code class="language-plaintext highlighter-rouge">sudo</code>, <code class="language-plaintext highlighter-rouge">ssh</code>, <code class="language-plaintext highlighter-rouge">passwd</code>, <code class="language-plaintext highlighter-rouge">login</code>, entre outros;</li> <li>Scripts com conteúdo suspeito (captura de senha, logs estranhos, exfiltração).</li> </ul> <p>Alguns comandos simples já ajudam a pegar coisas óbvias:</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>find /tmp  <span class="nt">-maxdepth</span> 2 <span class="nt">-type</span> f <span class="nt">-perm</span> <span class="nt">-111</span>
find /home <span class="nt">-maxdepth</span> 3 <span class="nt">-type</span> f <span class="nt">-perm</span> <span class="nt">-111</span> <span class="nt">-name</span> <span class="s1">'sudo'</span>
</code></pre></div></div> <h3 id="usar-ferramentas-tipo-pspy-também-no-blue-team">Usar ferramentas tipo pspy também no Blue Team</h3> <p>No lab, eu usei <code class="language-plaintext highlighter-rouge">pspy</code> para enxergar processos e encontrar oportunidades de ataque. Mas a mesma ideia funciona ao contrário:</p> <p>Em uma investigação forense ou um hunting pontual, rodar algo no estilo <code class="language-plaintext highlighter-rouge">pspy</code> ajuda a identificar:</p> <ul> <li>Scripts inesperados;</li> <li>Comandos <code class="language-plaintext highlighter-rouge">sudo</code> rodando em horários estranhos;</li> <li>Processos acessando <code class="language-plaintext highlighter-rouge">/etc/shadow</code>, <code class="language-plaintext highlighter-rouge">/etc/passwd</code> ou outros arquivos sensíveis.</li> </ul> <p>Claro: em produção, isso precisa ser feito com cuidado (carga, privacidade etc.), mas a ideia é válida.</p> <h3 id="checklist-rápido-de-hardening-para-automações-com-sudo">Checklist rápido de hardening para automações com sudo</h3> <p>Se você tem <code class="language-plaintext highlighter-rouge">cron</code>, <code class="language-plaintext highlighter-rouge">systemd</code>, scripts de manutenção, pipelines de CI/CD ou qualquer automação que roda com privilégios, vale passar por esse checklist:</p> <ol> <li><strong>Seu script realmente precisa de <code class="language-plaintext highlighter-rouge">sudo</code>?</strong> <ul> <li>Sempre que possível: <ul> <li>Execute o script diretamente como <code class="language-plaintext highlighter-rouge">root</code> (via systemd com <code class="language-plaintext highlighter-rouge">User=</code>/<code class="language-plaintext highlighter-rouge">Group=</code> bem definidos);</li> <li>Ou separe a parte privilegiada em um serviço dedicado, em vez de sair espalhando <code class="language-plaintext highlighter-rouge">sudo</code> dentro de scripts.</li> </ul> </li> <li>Regra de bolso: <strong>“sudo é interface pra humano, não pra script”</strong>. Se o script precisa de <code class="language-plaintext highlighter-rouge">root</code>, pense em rodá-lo no contexto certo desde o início.</li> </ul> </li> <li> <p><strong>Se precisar usar sudo, use caminho absoluto:</strong></p> <p>Dentro de scripts:</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># Evite:</span>
<span class="nb">sudo </span>comando
<span class="nb">sudo cat</span> /etc/shadow

<span class="c"># Prefira:</span>
/usr/bin/sudo /bin/comando
/usr/bin/sudo /bin/cat /etc/shadow
</code></pre></div> </div> <p>Mesma lógica para os binários chamados pelo <code class="language-plaintext highlighter-rouge">sudo</code> (<code class="language-plaintext highlighter-rouge">/bin/cat</code>, <code class="language-plaintext highlighter-rouge">/usr/sbin/service</code>).</p> </li> <li> <p><strong>Trate o PATH como superfície de ataque:</strong></p> <ul> <li> <p>Em scripts privilegiados, defina um <code class="language-plaintext highlighter-rouge">PATH</code> mínimo, controlado:</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">PATH</span><span class="o">=</span><span class="s2">"/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin"</span>
<span class="nb">export </span>PATH
</code></pre></div> </div> </li> <li>Não herde <code class="language-plaintext highlighter-rouge">PATH</code> do ambiente do usuário sem pensar;</li> <li>Nunca inclua diretórios escrevíveis por usuários (<code class="language-plaintext highlighter-rouge">/tmp</code>, <code class="language-plaintext highlighter-rouge">/var/tmp</code>, diretórios de home) no <code class="language-plaintext highlighter-rouge">PATH</code> de automações privilegiadas.</li> </ul> </li> <li> <p><strong>Revise o sudoers pensando em automações:</strong></p> <ul> <li>Use <code class="language-plaintext highlighter-rouge">visudo</code> e confira: <ul> <li>Regras com <code class="language-plaintext highlighter-rouge">NOPASSWD</code>: são realmente necessárias? Podem ser mais específicas?</li> <li> <p>Comandos permitidos: evite <code class="language-plaintext highlighter-rouge">ALL</code>, prefira linhas do tipo:</p> <div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>meu-user ALL=(root) NOPASSWD: /usr/bin/systemctl restart meu-servico
</code></pre></div> </div> </li> </ul> </li> <li>Avalie se o serviço não deveria rodar como <code class="language-plaintext highlighter-rouge">root</code> direto, em vez de usar <code class="language-plaintext highlighter-rouge">sudo</code> por baixo do pano;</li> <li> <p>Ative e use <code class="language-plaintext highlighter-rouge">secure_path</code> no <code class="language-plaintext highlighter-rouge">sudoers</code>:</p> <div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Defaults secure_path="/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin"
</code></pre></div> </div> </li> </ul> <p>Assim, mesmo quando scripts chamam <code class="language-plaintext highlighter-rouge">sudo</code>, o comando rodará com um <code class="language-plaintext highlighter-rouge">PATH</code> limpo.</p> </li> </ol> <h2 id="conclusão">Conclusão</h2> <p>No fim das contas, esse lab não foi só sobre “pegar root”. Ele funcionou quase como um raio-x de algo que a gente costuma ignorar: detalhes de ambiente, <code class="language-plaintext highlighter-rouge">PATH</code> solto demais, <code class="language-plaintext highlighter-rouge">sudo</code> em automações e aquele “depois eu arrumo” que vai ficando pra depois.</p> <p>O cenário é bem simples: um usuário comum, um serviço rodando em segundo plano, um <code class="language-plaintext highlighter-rouge">sudo</code> sem caminho absoluto e um <code class="language-plaintext highlighter-rouge">PATH</code> ajustado no lugar “certo”. Nada de exploit mirabolante, nada de zero-day — só a combinação de <strong>conveniência + descuido</strong>.</p> <p>A moral da história não é “nunca use sudo” ou “automatização é ruim”, mas sim:</p> <ul> <li>se o seu script precisa mesmo de privilégio, dê esse privilégio de forma explícita e controlada;</li> <li>trate <code class="language-plaintext highlighter-rouge">PATH</code>, <code class="language-plaintext highlighter-rouge">sudoers</code> e scripts de login como <strong>superfície de ataque</strong>, não só como “configuração de conforto”.</li> </ul>]]></content><author><name></name></author><category term="security"/><category term="linux"/><category term="lab-thm"/><category term="linux"/><category term="privilege-escalation"/><category term="sudo"/><category term="path-hijacking"/><category term="mitre-attack"/><category term="hardening"/><summary type="html"><![CDATA[Introdução Recentemente eu fiz o lab Eavesdropper – Find the Flag, no TryHackMe. À primeira vista, parecia “só mais um” desafio de escalonamento de privilégios em Linux. Na prática, ele acabou virando uma aula muito concreta sobre: Como o PATH pode ser abusado para rodar binários falsos. Como isso se conecta ao sudo. E, mais importante, como evitar esse tipo de ataque em ambientes de produção. Neste post vou contar rapidamente como funciona o ataque (sem código malicioso passo a passo) e, principalmente, quais são as boas práticas para se proteger desse tipo de vetor. Para quem é este post? Nível: intermediário em Linux. Pré-requisitos: Saber navegar no terminal (cd, ls, etc.) e usar sudo no dia a dia. Entender a diferença entre usuário comum e root. Já ter ouvido falar em /etc/passwd e /etc/shadow. Cenário do lab (versão resumida) No lab, eu tinha acesso SSH como um usuário comum, frank. O objetivo era, claro, virar root. Os passos principais: Usei uma ferramenta de monitoramento de processos (pspy) para observar o que o sistema estava executando em background. Em determinado momento aparecia algo como: UID=0 | sudo cat /etc/shadow Ou seja: algum processo estava chamando sudo para ler /etc/shadow. A partir daí, a ideia do lab era: se alguém está chamando sudo em um contexto onde o ambiente do usuário conta, dá pra enganar o sistema fazendo sudo apontar para outra coisa. Isso nos leva ao coração do ataque: PATH hijacking. Entendendo o PATH hijacking No Linux, quando você digita um comando como: sudo id o shell não “nasce sabendo” onde está sudo. Ele procura o binário percorrendo os diretórios definidos na variável de ambiente PATH, na ordem: echo $PATH # Exemplo típico: # /usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:... A lógica é: Procura sudo em /usr/local/sbin. Se não achar, tenta /usr/local/bin. Depois /usr/sbin. Depois /usr/bin. E assim por diante. Se eu conseguir colocar um diretório escrevível por mim (como /tmp ou ~/bin) no início do PATH, e criar um arquivo executável chamado sudo ali dentro, o shell passa a encontrar o meu sudo falso antes do /usr/bin/sudo legítimo. Exemplo conceitual: # (conceito) Colocar /tmp no começo do PATH export PATH=/tmp:$PATH # Agora, se existir /tmp/sudo e ele for executável: which sudo # /tmp/sudo Isso é PATH hijacking. No lab, o “pulo do gato” foi justamente ajustar o PATH no arquivo ~/.bashrc. Isso era preciso porque o “gatilho” do comando sudo /etc/shadow era no momento do login. E foi preciso garantir que a linha estivesse no fim do arquivo ~/.bashrc e viesse antes do PATH original. Assim, toda nova sessão bash do usuário já nascia com /tmp na frente – e qualquer sudo digitado naquela sessão cairia no binário falso. Diagrama rápido do fluxo [Fluxo normal] usuário/serviço -&gt; "sudo" -&gt; /usr/bin/sudo -&gt; /etc/shadow [Fluxo com PATH hijack] usuário/serviço -&gt; "sudo" -&gt; /tmp/sudo (malicioso) -&gt; /usr/bin/sudo -&gt; /etc/shadow Repare que o alvo final é o mesmo (/etc/shadow), mas no segundo caso existe uma etapa maliciosa no meio do caminho, que pode: capturar senha, registrar comandos, ou executar qualquer coisa antes de repassar para o sudo real. Onde isso vira ataque de verdade? Se eu consigo: Fazer o usuário (ou algum script) executar sudo sem caminho absoluto (apenas sudo, não /usr/bin/sudo). Num contexto onde o PATH é controlável. E colocar um binário/script falso chamado sudo à frente do /usr/bin. Então eu posso: Executar qualquer coisa no lugar do sudo real. E potencialmente roubar credenciais (por exemplo, pedindo a senha e guardando em algum lugar antes de repassar para o /usr/bin/sudo verdadeiro). Essa é a parte que, em ambiente real, vira uma técnica de Credential Access / Privilege Escalation. No lab, o objetivo era justamente explorar esse comportamento para capturar a senha e escalar para root. Em ambiente de produção, esse mesmo padrão é um incidente de segurança grave. No caso específico do lab, o mais curioso é que não era um usuário humano digitando sudo e a senha no terminal. Quem estava rodando sudo cat /etc/shadow era um serviço/script automatizado, em background, em um contexto de maior privilégio. Ou seja: Um processo legítimo chamava sudo sem caminho absoluto (sudo ..., e não /usr/bin/sudo ...). Esse processo rodava com privilégios elevados ou com regras de sudo permissivas. O meu sudo falso, em /tmp, era encontrado primeiro por causa do PATH. Em muitos exemplos de PATH hijacking a narrativa é “roubei a senha que o usuário digitou no prompt do sudo”. Neste lab, o cenário é mais sutil (e mais próximo de ambientes reais): É um serviço de sistema, com um fluxo automatizado. Que chama sudo como parte de uma rotina de início de sessão. E acaba sendo desviado para um binário malicioso por causa do PATH. O impacto é o mesmo (ou até pior): execução de código no contexto do serviço, potencialmente com privilégios altos, sem depender de nenhuma interação do usuário na frente do teclado. Conectando com o MITRE ATT&amp;CK Se olharmos esse lab com a lente do MITRE ATT&amp;CK, dá pra mapear bem o que está acontecendo e, principalmente, o papel das automações que abusam de sudo, não só do usuário na frente do terminal. Táticas envolvidas: Privilege Escalation (TA0004) – sair de usuário comum (frank) para root. Credential Access (TA0006) – porque o alvo intermediário é ler /etc/shadow e potencialmente quebrar senhas depois. PATH hijacking (T1574.007): Path Interception by PATH Environment Variable A técnica de colocar /tmp na frente do PATH e criar um sudo falso se encaixa em: T1574.007 – Hijack Execution Flow: Path Interception by PATH Environment Variable Referência oficial: https://attack.mitre.org/techniques/T1574/007/ Pontos em comum: Manipular a variável PATH. Colocar um binário malicioso antes do binário legítimo. Deixar o sistema chamar o executável “errado” quando alguém digita um comando sem caminho absoluto. No lab, isso acontece quando: Adiciono export PATH=/tmp:$PATH no arquivo do ~/.bashrc, que será carregado em cada nova sessão. Crio um /tmp/sudo malicioso. Deixo que um processo automatizado rode sudo sem especificar /usr/bin/sudo. Aqui o ponto não é só “enganar o usuário”, mas enganar o próprio serviço: o fluxo de execução do serviço é sequestrado via PATH hijacking. Abuso do sudo → T1548.003 – Sudo and Sudo Caching A outra peça é o uso (ou abuso) do sudo como mecanismo de elevação de privilégio dentro de scripts/serviços: T1548.003 – Abuse Elevation Control Mechanism: Sudo and Sudo Caching Referência oficial: https://attack.mitre.org/techniques/T1548/003/ No fluxo do lab: Um processo legítimo chama sudo cat /etc/shadow. Eu interfiro nesse fluxo com um sudo falso. A automação confia que sudo é o binário legítimo e que o ambiente está “limpo”. A partir daí, eu executo o que quiser no contexto daquele serviço (e/ou uso a credencial para obter root). Esse é exatamente o tipo de cenário descrito no ATT&amp;CK quando fala de: Scripts e jobs que dependem de sudo para subir privilégio. Regras de sudoers permissivas (NOPASSWD, comandos muito amplos). Cadeias de automação que confiam demais em sudo sem controlar ambiente e caminhos. Leitura de /etc/shadow → T1003.008 – /etc/passwd and /etc/shadow O comando visto no pspy não é qualquer coisa, é: sudo cat /etc/shadow Isso entra em: T1003.008 – OS Credential Dumping: /etc/passwd and /etc/shadow Objetivo clássico: Ler /etc/passwd e /etc/shadow; Fazer dump de hashes de senha; Permitir quebra offline com ferramentas como John the Ripper ou Hashcat. No lab, eu uso isso como parte de um cenário de escalonamento de privilégios. Na vida real, isso vira ponto de partida para: Account takeover; Movimento lateral; Criação de novas contas com privilégios elevados. Por que isso importa pra defesa? Olhar para o lab via MITRE ATT&amp;CK ajuda a transformar: “Ganhei root e peguei a flag” em: Técnicas mapeadas, com nomes e IDs. Pontos de detecção (onde você liga alertas). Pontos de mitigação (onde você faz hardening). Por exemplo: Para T1574.007 (PATH hijack): Monitorar alterações suspeitas em PATH; Monitorar criação de binários como sudo, ssh, passwd em diretórios de usuário ou em /tmp. Para T1548.003 (abuso de sudo): Auditar o /etc/sudoers; Reduzir comandos liberados via sudo; Registrar comandos sudo junto com usuário, TTY, host. Para T1003.008 (/etc/passwd e /etc/shadow): Alertar sempre que /etc/shadow for acessado fora de contextos esperados; Usar auditd/EDR para ver quem está lendo esse arquivo e como. Como impedir isso em ambientes de produção Nunca coloque diretórios escrevíveis no PATH (tipo /tmp) Isso vale tanto para usuários comuns quanto, principalmente, para root. Nunca deixe /tmp, /var/tmp ou qualquer diretório globalmente escrevível (drwxrwxrwt) no PATH. Evite também colocar diretórios do usuário (~/bin, ~/.local/bin) no PATH do root. Se algum script fizer isso, o risco de PATH hijack sobe muito: qualquer usuário que tiver permissão de escrita ali pode “injetar” binários falsos. Em scripts privilegiados, use caminhos absolutos Em scripts que rodam como root (cron, systemd, scripts de provisionamento etc.), não confie no PATH. Use sempre caminhos absolutos: # Em vez de: sudo cat /etc/shadow service ssh status # Use: /usr/bin/sudo /bin/cat /etc/shadow /usr/sbin/service ssh status Isso elimina a possibilidade de PATH hijack nesses pontos: mesmo que alguém consiga mexer no PATH, o comando chamado será o específico /usr/bin/sudo, e não “qualquer coisa chamada sudo”. Hardening do sudoers (e usar secure_path) No /etc/sudoers, existe a opção secure_path que define um PATH “forçado” para comandos executados via sudo, por exemplo: Defaults secure_path="/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin" Isso faz com que, quando alguém roda sudo comando, o PATH usado seja um conjunto de caminhos “limpos”, ignorando PATH adulterados no ambiente do usuário. Outras boas práticas no sudoers: Limitar o uso de NOPASSWD só ao estritamente necessário; Evitar comandos genéricos demais (tipo ALL); Revisar regularmente quem pode usar sudo e para quê. Monitorar scripts de login e variáveis de ambiente Pontos a revisar periodicamente: Arquivos globais: /etc/profile /etc/bash.bashrc /etc/zprofile, /etc/zshrc (se usar zsh) Arquivos por usuário: ~/.profile ~/.bash_profile ~/.bashrc ~/.zshrc Procure por: Linhas que alterem PATH de forma suspeita (PATH=..., export PATH=...); Inclusão de diretórios incomuns no começo do PATH; Comandos que modifiquem PATH de forma dinâmica. Ferramentas de integridade (tipo AIDE ou Tripwire) também podem ajudar a detectar mudanças inesperadas nesses arquivos. Auditar binários em diretórios “estranhos” De tempos em tempos, é útil varrer: /tmp /var/tmp Diretórios como ~/bin, ~/.local/bin Em busca de: Arquivos executáveis com nomes “sensíveis”: sudo, ssh, passwd, login, entre outros; Scripts com conteúdo suspeito (captura de senha, logs estranhos, exfiltração). Alguns comandos simples já ajudam a pegar coisas óbvias: find /tmp -maxdepth 2 -type f -perm -111 find /home -maxdepth 3 -type f -perm -111 -name 'sudo' Usar ferramentas tipo pspy também no Blue Team No lab, eu usei pspy para enxergar processos e encontrar oportunidades de ataque. Mas a mesma ideia funciona ao contrário: Em uma investigação forense ou um hunting pontual, rodar algo no estilo pspy ajuda a identificar: Scripts inesperados; Comandos sudo rodando em horários estranhos; Processos acessando /etc/shadow, /etc/passwd ou outros arquivos sensíveis. Claro: em produção, isso precisa ser feito com cuidado (carga, privacidade etc.), mas a ideia é válida. Checklist rápido de hardening para automações com sudo Se você tem cron, systemd, scripts de manutenção, pipelines de CI/CD ou qualquer automação que roda com privilégios, vale passar por esse checklist: Seu script realmente precisa de sudo? Sempre que possível: Execute o script diretamente como root (via systemd com User=/Group= bem definidos); Ou separe a parte privilegiada em um serviço dedicado, em vez de sair espalhando sudo dentro de scripts. Regra de bolso: “sudo é interface pra humano, não pra script”. Se o script precisa de root, pense em rodá-lo no contexto certo desde o início. Se precisar usar sudo, use caminho absoluto: Dentro de scripts: # Evite: sudo comando sudo cat /etc/shadow # Prefira: /usr/bin/sudo /bin/comando /usr/bin/sudo /bin/cat /etc/shadow Mesma lógica para os binários chamados pelo sudo (/bin/cat, /usr/sbin/service). Trate o PATH como superfície de ataque: Em scripts privilegiados, defina um PATH mínimo, controlado: PATH="/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin" export PATH Não herde PATH do ambiente do usuário sem pensar; Nunca inclua diretórios escrevíveis por usuários (/tmp, /var/tmp, diretórios de home) no PATH de automações privilegiadas. Revise o sudoers pensando em automações: Use visudo e confira: Regras com NOPASSWD: são realmente necessárias? Podem ser mais específicas? Comandos permitidos: evite ALL, prefira linhas do tipo: meu-user ALL=(root) NOPASSWD: /usr/bin/systemctl restart meu-servico Avalie se o serviço não deveria rodar como root direto, em vez de usar sudo por baixo do pano; Ative e use secure_path no sudoers: Defaults secure_path="/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin" Assim, mesmo quando scripts chamam sudo, o comando rodará com um PATH limpo. Conclusão No fim das contas, esse lab não foi só sobre “pegar root”. Ele funcionou quase como um raio-x de algo que a gente costuma ignorar: detalhes de ambiente, PATH solto demais, sudo em automações e aquele “depois eu arrumo” que vai ficando pra depois. O cenário é bem simples: um usuário comum, um serviço rodando em segundo plano, um sudo sem caminho absoluto e um PATH ajustado no lugar “certo”. Nada de exploit mirabolante, nada de zero-day — só a combinação de conveniência + descuido. A moral da história não é “nunca use sudo” ou “automatização é ruim”, mas sim: se o seu script precisa mesmo de privilégio, dê esse privilégio de forma explícita e controlada; trate PATH, sudoers e scripts de login como superfície de ataque, não só como “configuração de conforto”.]]></summary></entry></feed>