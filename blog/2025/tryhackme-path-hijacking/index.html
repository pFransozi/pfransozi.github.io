<!DOCTYPE html> <html lang="pt"> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title> PATH hijacking no Linux: sudo, PATH e root | Philipe Fransozi </title> <meta name="author" content="Philipe Fransozi"> <meta name="description" content="Um resumo de como um simples PATH hijacking no Linux pode render acesso root e como evitar esse tipo de falha em ambientes de produção."> <meta name="keywords" content="jekyll, jekyll-theme, academic-website, portfolio-website"> <link rel="stylesheet" href="/assets/css/bootstrap.min.css?a4b3f509e79c54a512b890d73235ef04"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link defer rel="stylesheet" href="/assets/css/academicons.min.css?f0b7046b84e425c55f3463ac249818f5"> <link defer rel="stylesheet" href="/assets/css/scholar-icons.css?62b2ac103a88034e6882a5be5f3e2772"> <link defer rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons&amp;display=swap"> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-github.css?591dab5a4e56573bf4ef7fd332894c99" media="" id="highlight_theme_light"> <link rel="shortcut icon" href="data:image/svg+xml,&lt;svg%20xmlns=%22http://www.w3.org/2000/svg%22%20viewBox=%220%200%20100%20100%22&gt;&lt;text%20y=%22.9em%22%20font-size=%2290%22&gt;%E2%9A%9B%EF%B8%8F&lt;/text&gt;&lt;/svg&gt;"> <link rel="stylesheet" href="/assets/css/main.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="canonical" href="https://pfransozi.github.io/blog/2025/tryhackme-path-hijacking/"> <script src="/assets/js/theme.js?a81d82887dd692e91686b43de4542f18"></script> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-native.css?5847e5ed4a4568527aa6cfab446049ca" media="none" id="highlight_theme_dark"> <script>
    initTheme();
  </script> </head> <body class="fixed-top-nav "> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top" role="navigation"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/"> Philipe Fransozi </a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">about </a> </li> <li class="nav-item active"> <a class="nav-link" href="/blog/">blog </a> </li> <li class="nav-item "> <a class="nav-link" href="/publications/">publications </a> </li> <li class="nav-item "> <a class="nav-link" href="/projects/">projects </a> </li> <li class="nav-item "> <a class="nav-link" href="/repositories/">repositories </a> </li> <li class="nav-item "> <a class="nav-link" href="/teaching/">teaching </a> </li> <li class="nav-item"> <button id="search-toggle" title="Search" onclick="openSearchModal()"> <span class="nav-link">ctrl k <i class="ti ti-search"></i></span> </button> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="ti ti-sun-moon" id="light-toggle-system"></i> <i class="ti ti-moon-filled" id="light-toggle-dark"></i> <i class="ti ti-sun-filled" id="light-toggle-light"></i> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="container mt-5" role="main"> <div class="post"> <header class="post-header"> <h1 class="post-title">PATH hijacking no Linux: sudo, PATH e root</h1> <p class="post-meta"> Created on November 30, 2025 </p> <p class="post-tags"> <a href="/blog/2025"> <i class="fa-solid fa-calendar fa-sm"></i> 2025 </a>   ·   <a href="/blog/tag/linux"> <i class="fa-solid fa-hashtag fa-sm"></i> linux</a>   <a href="/blog/tag/privilege-escalation"> <i class="fa-solid fa-hashtag fa-sm"></i> privilege-escalation</a>   <a href="/blog/tag/sudo"> <i class="fa-solid fa-hashtag fa-sm"></i> sudo</a>   <a href="/blog/tag/path-hijacking"> <i class="fa-solid fa-hashtag fa-sm"></i> path-hijacking</a>   <a href="/blog/tag/mitre-attck"> <i class="fa-solid fa-hashtag fa-sm"></i> mitre-attck</a>   ·   <a href="/blog/category/ciberseguran%C3%A7a"> <i class="fa-solid fa-tag fa-sm"></i> cibersegurança</a>   <a href="/blog/category/linux"> <i class="fa-solid fa-tag fa-sm"></i> linux</a>   <a href="/blog/category/lab-thm"> <i class="fa-solid fa-tag fa-sm"></i> lab-thm</a> </p> </header> <article class="post-content"> <div id="markdown-content"> <h2 id="introdução">Introdução</h2> <p>Recentemente eu fiz o lab <strong>Eavesdropper – Find the Flag</strong>, no TryHackMe. À primeira vista, parecia “só mais um” desafio de escalonamento de privilégios em Linux. Na prática, ele acabou virando uma aula muito concreta sobre:</p> <ul> <li>Como o <code class="language-plaintext highlighter-rouge">PATH</code> pode ser abusado para rodar binários falsos.</li> <li>Como isso se conecta ao <code class="language-plaintext highlighter-rouge">sudo</code>.</li> <li>E, mais importante: como evitar esse tipo de ataque em ambientes de produção.</li> </ul> <p>Neste post vou contar rapidamente como funciona o ataque (sem código malicioso passo a passo) e, principalmente, quais são as boas práticas para se proteger desse tipo de vetor.</p> <hr> <h2 id="cenário-do-lab-versão-resumida">Cenário do lab (versão resumida)</h2> <p>No lab, eu tinha acesso SSH como um usuário comum, <code class="language-plaintext highlighter-rouge">frank</code>. O objetivo era, claro, virar <code class="language-plaintext highlighter-rouge">root</code>. Passos principais que fiz:</p> <ol> <li>Usei uma ferramenta de monitoramento de processos (<code class="language-plaintext highlighter-rouge">pspy</code>) para observar o que o sistema estava executando em background.</li> <li>Em determinado momento aparecia algo como:</li> </ol> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">UID</span><span class="o">=</span>0 | <span class="nb">sudo cat</span> /etc/shadow
</code></pre></div></div> <p>Ou seja: algum processo estava chamando <code class="language-plaintext highlighter-rouge">sudo</code> para ler <code class="language-plaintext highlighter-rouge">/etc/shadow</code>.</p> <p>A partir daí, a ideia do lab era: se alguém está chamando <code class="language-plaintext highlighter-rouge">sudo</code> em um contexto onde o ambiente do usuário conta, dá pra enganar o sistema fazendo <code class="language-plaintext highlighter-rouge">sudo</code> apontar para outra coisa. Isso nos leva ao coração do ataque: PATH hijacking.</p> <h2 id="entendendo-o-path-hijacking">Entendendo o PATH hijacking</h2> <p>No Linux, quando você digita um comando como:</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="nb">sudo id</span>
</code></pre></div></div> <p>O shell não “nasce sabendo” onde está <code class="language-plaintext highlighter-rouge">sudo</code>. Ele procura o binário percorrendo os diretórios definidos na variável de ambiente <code class="language-plaintext highlighter-rouge">PATH</code>, na ordem:</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="nb">echo</span> <span class="nv">$PATH</span>
    <span class="c"># Exemplo típico:</span>
    /usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:...
</code></pre></div></div> <p>A lógica é:</p> <ol> <li>Procura sudo em <code class="language-plaintext highlighter-rouge">/usr/local/sbin</code>.</li> <li>Se não achar, tenta <code class="language-plaintext highlighter-rouge">/usr/local/bin</code>.</li> <li>Depois <code class="language-plaintext highlighter-rouge">/usr/sbin</code>.</li> <li>Depois <code class="language-plaintext highlighter-rouge">/usr/bin</code>.</li> </ol> <p>E assim por diante. Se eu conseguir colocar um diretório escrevível por mim (como <code class="language-plaintext highlighter-rouge">/tmp</code> ou <code class="language-plaintext highlighter-rouge">~/bin</code>) no início do PATH, e criar um arquivo executável chamado sudo ali dentro, o shell passa a encontrar o meu sudo falso antes do <code class="language-plaintext highlighter-rouge">/usr/bin/sudo</code> legítimo. Exemplo conceitual:</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># (conceito) Colocar /tmp no começo do PATH</span>
<span class="nb">export </span><span class="nv">PATH</span><span class="o">=</span>/tmp:<span class="nv">$PATH</span>
<span class="c"># Agora, se existir /tmp/sudo e ele for executável:</span>
which <span class="nb">sudo</span>
<span class="c"># /tmp/sudo</span>
</code></pre></div></div> <p>Isso é PATH hijacking. No lab, o “pulo do gato” foi justamente: ajustar o <code class="language-plaintext highlighter-rouge">PATH</code> no arquivo <code class="language-plaintext highlighter-rouge">~/.bashrc</code>. Isso era preciso porque o “gatilho” do comando <code class="language-plaintext highlighter-rouge">sudo /etc/shadow</code> era no momento do login. E foi preciso garantir que a linha estivesse no fim do arquivo <code class="language-plaintext highlighter-rouge">~/.bashrc</code> e viesse antes do PATH original. Assim, toda nova sessão <code class="language-plaintext highlighter-rouge">bash</code> do usuário já nascia com <code class="language-plaintext highlighter-rouge">/tmp</code> na frente – e qualquer <code class="language-plaintext highlighter-rouge">sudo</code> digitado naquela sessão cairia no binário falso.</p> <h2 id="onde-isso-vira-ataque-de-verdade">Onde isso vira ataque de verdade?</h2> <p>Se eu consigo:</p> <ol> <li>Fazer o usuário (ou algum script) executar sudo sem caminho absoluto (apenas <code class="language-plaintext highlighter-rouge">sudo</code>, não <code class="language-plaintext highlighter-rouge">/usr/bin/sudo</code>).</li> <li>Num contexto onde o <code class="language-plaintext highlighter-rouge">PATH</code> é controlável.</li> <li>E colocar um binário/script falso chamado <code class="language-plaintext highlighter-rouge">sudo</code> à frente do <code class="language-plaintext highlighter-rouge">/usr/bin</code>.</li> </ol> <p>Então eu posso:</p> <ol> <li>Executar qualquer coisa no lugar do <code class="language-plaintext highlighter-rouge">sudo</code> real.</li> <li>E potencialmente roubar credenciais (por exemplo, pedindo a senha e guardando em algum lugar antes de repassar para o <code class="language-plaintext highlighter-rouge">/usr/bin/sudo</code> verdadeiro).</li> </ol> <p>Essa é a parte que, em ambiente real, vira uma técnica de <strong>Credential Access</strong> / <strong>Privilege Escalation</strong>. No lab, o objetivo era justamente explorar esse comportamento para capturar a senha e escalar para <code class="language-plaintext highlighter-rouge">root</code>. Em ambiente de produção, esse mesmo padrão é um incidente de segurança grave.</p> <p>No caso específico no lab, o mais curioso é que <strong>não era um usuário humano digitando <code class="language-plaintext highlighter-rouge">sudo</code> e a senha no terminal</strong>. Quem estava rodando <code class="language-plaintext highlighter-rouge">sudo cat /etc/shadow</code> era <strong>um serviço/script automatizado</strong>, em background, em um contexto de maior privilégio.</p> <p>Ou seja:</p> <ul> <li>Um processo legítimo chamava <code class="language-plaintext highlighter-rouge">sudo</code> sem caminho absoluto (<code class="language-plaintext highlighter-rouge">sudo ...</code>, e não <code class="language-plaintext highlighter-rouge">/usr/bin/sudo ...</code>).</li> <li>Esse processo rodava com privilégios elevados ou com regras de <code class="language-plaintext highlighter-rouge">sudo</code> permissivas.</li> <li>O meu <code class="language-plaintext highlighter-rouge">sudo</code> falso, em <code class="language-plaintext highlighter-rouge">/tmp</code>, era encontrado primeiro por causa do <code class="language-plaintext highlighter-rouge">PATH</code>.</li> </ul> <p>Em muitos exemplos de PATH hijacking a narrativa é “roubei a senha que o usuário digitou no prompt do sudo”. Neste lab, o cenário é mais sutil (e mais próximo de ambientes reais):</p> <ul> <li>É um <strong>serviço de sistema</strong>, com um fluxo automatizado.</li> <li>Que chama <code class="language-plaintext highlighter-rouge">sudo</code> como parte de uma rotina de iníco de sessão.</li> <li>E acaba sendo desviado para um binário malicioso por causa do <code class="language-plaintext highlighter-rouge">PATH</code>.</li> </ul> <p>O impacto é o mesmo (ou até pior): <strong>execução de código no contexto do serviço</strong>, potencialmente com privilégios altos, sem depender de nenhuma interação do usuário na frente do teclado.</p> <h2 id="conectando-com-o-mitre-attck">Conectando com o MITRE ATT&amp;CK</h2> <p>Se olharmos esse lab com a lente do MITRE ATT&amp;CK, dá pra mapear bem o que está acontecendo e, principalmente, o papel das automações que abusam de sudo, não só do usuário na frente do terminal.</p> <p>Táticas envolvidas:</p> <ul> <li> <strong>Privilege Escalation</strong> (TA0004) – sair de usuário comum (<code class="language-plaintext highlighter-rouge">frank</code>) para <code class="language-plaintext highlighter-rouge">root</code>.</li> <li> <strong>Credential Access</strong> (TA0006) – porque o alvo intermediário é ler <code class="language-plaintext highlighter-rouge">/etc/shadow</code> e potencialmente quebrar senhas depois.</li> </ul> <h3 id="path-hijacking-t1574007--path-interception-by-path-environment-variable"> <code class="language-plaintext highlighter-rouge">PATH</code> hijacking (T1574.007): <code class="language-plaintext highlighter-rouge">Path</code> Interception by <code class="language-plaintext highlighter-rouge">PATH</code> Environment Variable</h3> <p>A técnica de colocar <code class="language-plaintext highlighter-rouge">/tmp</code> na frente do <code class="language-plaintext highlighter-rouge">PATH</code> e criar um <code class="language-plaintext highlighter-rouge">sudo</code> falso se encaixa em:</p> <div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>T1574.007 – Hijack Execution Flow: Path Interception by PATH Environment Variable
</code></pre></div></div> <p>Pontos em comum:</p> <ul> <li>Manipular a variável PATH.</li> <li>Colocar um binário malicioso antes do binário legítimo.</li> <li>Deixar o sistema chamar o executável “errado” quando alguém digita um comando sem caminho absoluto.</li> </ul> <p>No lab, isso acontece quando:</p> <ul> <li>Adiciono <code class="language-plaintext highlighter-rouge">export PATH=/tmp:$PATH</code> no arquivo do <code class="language-plaintext highlighter-rouge">~/.bashrc</code>, que será carregado em cada nova sessão.</li> <li>Crio um <code class="language-plaintext highlighter-rouge">/tmp/sudo</code> malicioso.</li> <li>Deixo que um processo automatizado rode <code class="language-plaintext highlighter-rouge">sudo</code> sem especificar <code class="language-plaintext highlighter-rouge">/usr/bin/sudo</code>.</li> </ul> <p>Aqui o ponto não é só “enganar o usuário”, mas enganar o próprio serviço: o fluxo de execução do serviço é sequestrado via PATH hijacking.</p> <h3 id="abuso-do-sudo--t1548003--sudo-and-sudo-caching">Abuso do <code class="language-plaintext highlighter-rouge">sudo</code> → T1548.003 – Sudo and Sudo Caching</h3> <p>A outra peça é o uso (ou abuso) do <code class="language-plaintext highlighter-rouge">sudo</code> como mecanismo de elevação de privilégio dentro de scripts/serviços:</p> <div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>T1548.003 – Abuse Elevation Control Mechanism: Sudo and Sudo Caching
</code></pre></div></div> <p>No fluxo do lab:</p> <ul> <li>Um processo legítimo chama <code class="language-plaintext highlighter-rouge">sudo cat /etc/shadow</code>.</li> <li>Eu interfiro nesse fluxo com um <code class="language-plaintext highlighter-rouge">sudo</code> falso.</li> <li>A automação confia que <code class="language-plaintext highlighter-rouge">sudo</code> é o binário legítimo e que o ambiente está “limpo”.</li> <li>A partir daí, eu executo o que quiser no contexto daquele serviço (e/ou uso a credencial para obter root).</li> </ul> <p>Esse é exatamente o tipo de cenário descrito no ATT&amp;CK quando fala de:</p> <ul> <li>Scripts e jobs que dependem de sudo para subir privilégio.</li> <li>Regras de <code class="language-plaintext highlighter-rouge">sudoers</code> permissivas (<code class="language-plaintext highlighter-rouge">NOPASSWD</code>, comandos muito amplos).</li> <li>Cadeias de automação que confiam demais em <code class="language-plaintext highlighter-rouge">sudo</code> sem controlar ambiente e caminhos.</li> </ul> <h3 id="leitura-de-etcshadow--t1003008--etcpasswd-and-etcshadow">Leitura de /etc/shadow → T1003.008 – /etc/passwd and /etc/shadow</h3> <p>O comando visto no pspy não é qualquer coisa, é:</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo cat</span> /etc/shadow
</code></pre></div></div> <p>Isso entra em:</p> <div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>T1003.008 – OS Credential Dumping: /etc/passwd and /etc/shadow
</code></pre></div></div> <p>O objetivo clássico:</p> <ul> <li>Ler <code class="language-plaintext highlighter-rouge">/etc/passwd</code> e <code class="language-plaintext highlighter-rouge">/etc/shadow</code>.</li> <li>Fazer dump de hashes de senha.</li> <li>Permitir quebra offline com ferramentas como John the Ripper ou Hashcat.</li> </ul> <p>No lab, eu uso isso como parte de um cenário de escalonamento de privilégios. Na vida real, isso vira ponto de partida para:</p> <ul> <li>Account takeover.</li> <li>Movimento lateral.</li> <li>Criação de novas contas com privilégios elevados.</li> </ul> <h3 id="por-que-isso-importa-pra-defesa">Por que isso importa pra defesa?</h3> <p>Olhar para o lab via MITRE ATT&amp;CK ajuda a transformar: “Ganhei root e peguei a flag” em:</p> <ul> <li>Técnicas mapeadas, com nomes e IDs.</li> <li>Pontos de detecção (onde você liga alertas).</li> <li>Pontos de mitigação (onde você faz hardening).</li> </ul> <p>Por exemplo:</p> <ul> <li>Para T1574.007 (<code class="language-plaintext highlighter-rouge">PATH</code> hijack): <ul> <li>Monitorar alterações suspeitas em <code class="language-plaintext highlighter-rouge">PATH</code>.</li> <li>Monitorar criação de binários como <code class="language-plaintext highlighter-rouge">sudo</code>, <code class="language-plaintext highlighter-rouge">ssh</code>, <code class="language-plaintext highlighter-rouge">passwd</code> em diretórios de usuário ou em <code class="language-plaintext highlighter-rouge">/tmp</code>.</li> </ul> </li> <li>Para T1548.003 (<code class="language-plaintext highlighter-rouge">sudo</code> abuse) <ul> <li>Auditar o <code class="language-plaintext highlighter-rouge">/etc/sudoers</code>.</li> <li>Reduzir comandos liberados via <code class="language-plaintext highlighter-rouge">sudo</code>.</li> <li>Registrar comandos <code class="language-plaintext highlighter-rouge">sudo</code> junto com usuário, TTY, host.</li> </ul> </li> <li>Para T1003.008 ({ }) <ul> <li>Alertar sempre que <code class="language-plaintext highlighter-rouge">/etc/shadow</code> for acessado fora de contextos esperados</li> <li>Usar auditd/EDR para ver quem está lendo esse arquivo e como.</li> </ul> </li> </ul> <h2 id="como-impedir-isso-em-ambientes-de-produção">Como impedir isso em ambientes de produção</h2> <h3 id="nunca-coloque-diretórios-escrevíveis-no-path-tipo-tmp">Nunca coloque diretórios escrevíveis no <code class="language-plaintext highlighter-rouge">PATH</code> (tipo <code class="language-plaintext highlighter-rouge">/tmp</code>)</h3> <p>Isso vale tanto para usuários comuns quanto, principalmente, para <code class="language-plaintext highlighter-rouge">root</code>.</p> <ul> <li>Nunca deixe <code class="language-plaintext highlighter-rouge">/tmp</code>, <code class="language-plaintext highlighter-rouge">/var/tmp</code> ou qualquer diretório globalmente escrevível (<code class="language-plaintext highlighter-rouge">drwxrwxrwt</code>) no <code class="language-plaintext highlighter-rouge">PATH</code>.</li> <li>Evite também colocar diretórios do usuário (<code class="language-plaintext highlighter-rouge">~/bin</code>, <code class="language-plaintext highlighter-rouge">~/.local/bin</code>) no <code class="language-plaintext highlighter-rouge">PATH</code> do <code class="language-plaintext highlighter-rouge">root</code>.</li> </ul> <p>Se algum script fizer isso, o risco de PATH hijack sobe muito: qualquer usuário que tiver permissão de escrita ali pode “injetar” binários falsos.</p> <h3 id="em-scripts-privilegiados-use-caminhos-absolutos">Em scripts privilegiados, use caminhos absolutos</h3> <p>Em scripts que rodam como <code class="language-plaintext highlighter-rouge">root</code> (<code class="language-plaintext highlighter-rouge">cron</code>, <code class="language-plaintext highlighter-rouge">systemd</code>, scripts de provisionamento etc.), não confie no <code class="language-plaintext highlighter-rouge">PATH</code>. Use sempre caminhos absolutos:</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># Em vez de:</span>
<span class="nb">sudo cat</span> /etc/shadow
service ssh status
<span class="c"># Use:</span>
/usr/bin/sudo /bin/cat /etc/shadow
/usr/sbin/service ssh status
</code></pre></div></div> <p>Isso elimina a possibilidade de PATH hijack nesses pontos: mesmo que alguém consiga mexer no <code class="language-plaintext highlighter-rouge">PATH</code>, o comando chamado será o específico <code class="language-plaintext highlighter-rouge">/usr/bin/sudo</code>, e não “qualquer coisa chamada sudo”.</p> <h3 id="hardening-do-sudoers-e-usar-secure_path">Hardening do sudoers (e usar secure_path)</h3> <p>No <code class="language-plaintext highlighter-rouge">/etc/sudoers</code>, existe a opção <code class="language-plaintext highlighter-rouge">secure_path</code> que define um <code class="language-plaintext highlighter-rouge">PATH</code> “forçado” para comandos executados via <code class="language-plaintext highlighter-rouge">sudo</code>, por exemplo:</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Defaults <span class="nv">secure_path</span><span class="o">=</span><span class="s2">"/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin"</span>
</code></pre></div></div> <p>Isso faz com que, quando alguém roda <code class="language-plaintext highlighter-rouge">sudo</code> comando, o <code class="language-plaintext highlighter-rouge">PATH</code> usado seja um conjunto de caminhos “limpos”, ignorando <code class="language-plaintext highlighter-rouge">PATH</code> adulterados no ambiente do usuário.</p> <p>Outras boas práticas no sudoers:</p> <ul> <li>Limitar o uso de NOPASSWD só ao estritamente necessário.</li> <li>Evitar comandos genéricos demais (tipo ALL).</li> <li>Revisar regularmente quem pode usar sudo e para quê.</li> </ul> <h3 id="monitorar-scripts-de-login-e-variáveis-de-ambiente">Monitorar scripts de login e variáveis de ambiente</h3> <p>Pontos a revisar periodicamente:</p> <p>Arquivos globais:</p> <ul> <li> <code class="language-plaintext highlighter-rouge">/etc/profile</code>.</li> <li> <code class="language-plaintext highlighter-rouge">/etc/bash.bashrc</code>.</li> <li> <code class="language-plaintext highlighter-rouge">/etc/zprofile</code>, <code class="language-plaintext highlighter-rouge">/etc/zshrc</code> (se usar zsh).</li> </ul> <p>Arquivos por usuário:</p> <ul> <li> <code class="language-plaintext highlighter-rouge">~/.profile</code>.</li> <li> <code class="language-plaintext highlighter-rouge">~/.bash_profile</code>.</li> <li> <code class="language-plaintext highlighter-rouge">~/.bashrc</code>.</li> <li> <code class="language-plaintext highlighter-rouge">~/.zshrc</code>.</li> </ul> <p>Procure por:</p> <ul> <li>Linhas que alterem <code class="language-plaintext highlighter-rouge">PATH</code> de forma suspeita (<code class="language-plaintext highlighter-rouge">PATH=...</code>, <code class="language-plaintext highlighter-rouge">export PATH=...</code>).</li> <li>Inclusão de diretórios incomuns no começo do <code class="language-plaintext highlighter-rouge">PATH</code>.</li> <li>Comandos que modifiquem <code class="language-plaintext highlighter-rouge">PATH</code> de forma dinâmica</li> </ul> <p>Ferramentas de integridade (tipo AIDE, Tripwire) também podem ajudar a detectar mudanças inesperadas nesses arquivos.</p> <h3 id="auditar-binários-em-diretórios-estranhos">Auditar binários em diretórios “estranhos”</h3> <p>De tempos em tempos, é útil varrer:</p> <ul> <li> <code class="language-plaintext highlighter-rouge">/tmp</code>.</li> <li> <code class="language-plaintext highlighter-rouge">/var/tmp</code>.</li> <li>Diretórios como <code class="language-plaintext highlighter-rouge">~/bin</code>, <code class="language-plaintext highlighter-rouge">~/.local/bin</code>.</li> </ul> <p>Em busca de:</p> <ul> <li>Arquivos executáveis com nomes “sensíveis”: <code class="language-plaintext highlighter-rouge">sudo</code>, <code class="language-plaintext highlighter-rouge">ssh</code>, <code class="language-plaintext highlighter-rouge">passwd</code>, <code class="language-plaintext highlighter-rouge">login</code>, entre outros.</li> <li>Scripts com conteúdo suspeito (captura de senha, logs estranhos, exfiltração).</li> </ul> <p>Alguns comandos simples, já ajudam a pegar coisas óbvias:</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>find /tmp  <span class="nt">-maxdepth</span> 2 <span class="nt">-type</span> f <span class="nt">-perm</span> <span class="nt">-111</span>
find /home <span class="nt">-maxdepth</span> 3 <span class="nt">-type</span> f <span class="nt">-perm</span> <span class="nt">-111</span> <span class="nt">-name</span> <span class="s1">'sudo'</span>
</code></pre></div></div> <h3 id="usar-ferramentas-tipo-pspy-também-no-blue-team">Usar ferramentas tipo pspy também no Blue Team</h3> <p>No lab, eu usei pspy para enxergar processos e encontrar oportunidades de ataque. Mas a mesma ideia funciona ao contrário:</p> <p>Em uma investigação forense ou um hunting pontual, rodar algo no estilo pspy ajuda a identificar:</p> <ul> <li>scripts inesperados</li> <li>comandos <code class="language-plaintext highlighter-rouge">sudo</code> rodando em horários estranhos</li> <li>processos acessando <code class="language-plaintext highlighter-rouge">/etc/shadow</code>, <code class="language-plaintext highlighter-rouge">/etc/passwd</code> ou outros arquivos sensíveis</li> </ul> <p>Claro: em produção, isso precisa ser feito com cuidado (carga, privacidade etc.), mas a ideia é válida.</p> <h3 id="checklist-rápido-de-hardening-para-automações-com-sudo">Checklist rápido de hardening para automações com sudo</h3> <p>Se você tem cron, systemd, scripts de manutenção, pipelines de CI/CD ou qualquer automação que roda com privilégios, vale passar por esse checklist:</p> <ol> <li>Seu script realmente precisa de <code class="language-plaintext highlighter-rouge">sudo</code>? <ul> <li>Sempre que possível: <ul> <li>Execute o script diretamente como <code class="language-plaintext highlighter-rouge">root</code> (via systemd com User=/Group= bem definidos).</li> <li>Ou separe a parte privilegiada em um serviço dedicado, em vez de sair espalhando <code class="language-plaintext highlighter-rouge">sudo</code> dentro de scripts.</li> </ul> </li> <li>Regra de bolso: “<code class="language-plaintext highlighter-rouge">sudo</code> é interface pra humano, não pra script”. Se o script precisa de <code class="language-plaintext highlighter-rouge">root</code>, pense em rodá-lo no contexto certo desde o início.</li> </ul> </li> <li>Se precisar usar sudo, use caminho absoluto: <ul> <li>Dentro de scripts: <div class="language-bash highlighter-rouge"> <div class="highlight"><pre class="highlight"><code>  <span class="c"># Evite:</span>
  <span class="nb">sudo </span>comando
  <span class="nb">sudo cat</span> /etc/shadow

  <span class="c"># Prefira:</span>
  /usr/bin/sudo /bin/comando
  /usr/bin/sudo /bin/cat /etc/shadow
</code></pre></div> </div> <p>Mesma lógica para os binários chamados pelo sudo (<code class="language-plaintext highlighter-rouge">/bin/cat</code>, <code class="language-plaintext highlighter-rouge">/usr/sbin/service</code>).</p> </li> </ul> </li> <li>Trate o <code class="language-plaintext highlighter-rouge">PATH</code> como superfície de ataque: <ul> <li>Em scripts privilegiados, defina um PATH mínimo, controlado: <div class="language-bash highlighter-rouge"> <div class="highlight"><pre class="highlight"><code>  <span class="nv">PATH</span><span class="o">=</span><span class="s2">"/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin"</span>
  <span class="nb">export </span>PATH
</code></pre></div> </div> </li> <li>Não herde PATH do ambiente do usuário sem pensar.</li> <li>Nunca inclua diretórios escrevíveis por usuários (<code class="language-plaintext highlighter-rouge">/tmp</code>, <code class="language-plaintext highlighter-rouge">/var/tmp</code>, diretórios de home) no <code class="language-plaintext highlighter-rouge">PATH</code> de automações privilegiadas.</li> </ul> </li> <li>Revise o sudoers pensando em automações: <ul> <li>Use visudo e confira: <ul> <li>Regras com NOPASSWD: são realmente necessárias? Podem ser mais específicas?</li> <li>Comandos permitidos: evite ALL, prefira linhas do tipo: <div class="language-bash highlighter-rouge"> <div class="highlight"><pre class="highlight"><code>  meu-user <span class="nv">ALL</span><span class="o">=(</span>root<span class="o">)</span> NOPASSWD: /usr/bin/systemctl restart meu-servico
</code></pre></div> </div> </li> </ul> </li> <li>Avalie se o serviço não deveria rodar como root direto, em vez de usar sudo por baixo do pano.</li> <li>Ative e use <code class="language-plaintext highlighter-rouge">secure_path</code> no sudoers: <div class="language-bash highlighter-rouge"> <div class="highlight"><pre class="highlight"><code>  Defaults <span class="nv">secure_path</span><span class="o">=</span><span class="s2">"/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin"</span>
</code></pre></div> </div> <p>Assim, mesmo quando scripts chamam sudo, o comando rodará com um PATH limpo.</p> </li> </ul> </li> </ol> <h2 id="conclusão">Conclusão</h2> <p>No fim das contas, esse lab não foi só sobre “pegar root”. Ele funcionou quase como um raio-x de algo que a gente costuma ignorar: detalhes de ambiente, <code class="language-plaintext highlighter-rouge">PATH</code> solto demais, <code class="language-plaintext highlighter-rouge">sudo</code> em automações e aquele “depois eu arrumo” que vai ficando pra depois.</p> <p>O cenário é bem simples: um usuário comum, um serviço rodando em segundo plano, um <code class="language-plaintext highlighter-rouge">sudo</code> sem caminho absoluto e um <code class="language-plaintext highlighter-rouge">PATH</code> ajustado no lugar “certo”. Nada de exploit mirabolante, nada de zero-day — só a combinação de conveniência + descuido.</p> <p>A moral da história não é “nunca use sudo” ou “automatização é ruim”, mas sim:</p> <ul> <li>se o seu script precisa mesmo de privilégio, dê esse privilégio de forma explícita e controlada;</li> <li>trate <code class="language-plaintext highlighter-rouge">PATH</code>, <code class="language-plaintext highlighter-rouge">sudoers</code> e scripts de login como superfície de ataque, não só como “configuração de conforto”.</li> </ul> </div> </article> <br> <hr> <br> <ul class="list-disc pl-8"></ul> <h2 class="text-3xl font-semibold mb-4 mt-12">Enjoy Reading This Article?</h2> <p class="mb-2">Here are some more articles you might like to read next:</p> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="https://blog.google/technology/ai/google-gemini-update-flash-ai-assistant-io-2024/" target="_blank" rel="external nofollow noopener">Google Gemini updates: Flash 1.5, Gemma 2 and Project Astra</a> <svg width="1rem" height="1rem" viewbox="0 0 30 30" xmlns="http://www.w3.org/2000/svg"> <path d="M17 13.5v6H5v-12h6m3-3h6v6m0-6-9 9" class="icon_svg-stroke" stroke="#999" stroke-width="1.5" fill="none" fill-rule="evenodd" stroke-linecap="round" stroke-linejoin="round"></path> </svg> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="https://medium.com/@al-folio/displaying-external-posts-on-your-al-folio-blog-b60a1d241a0a?source=rss-17feae71c3c4------2" target="_blank" rel="external nofollow noopener">Displaying External Posts on Your al-folio Blog</a> <svg width="1rem" height="1rem" viewbox="0 0 30 30" xmlns="http://www.w3.org/2000/svg"> <path d="M17 13.5v6H5v-12h6m3-3h6v6m0-6-9 9" class="icon_svg-stroke" stroke="#999" stroke-width="1.5" fill="none" fill-rule="evenodd" stroke-linecap="round" stroke-linejoin="round"></path> </svg> </li> </div> </div> <footer class="fixed-bottom" role="contentinfo"> <div class="container mt-0"> © Copyright 2025 Philipe Fransozi. Powered by <a href="https://jekyllrb.com/" target="_blank" rel="external nofollow noopener">Jekyll</a> with <a href="https://github.com/alshedivat/al-folio" rel="external nofollow noopener" target="_blank">al-folio</a> theme. Hosted by <a href="https://pages.github.com/" target="_blank" rel="external nofollow noopener">GitHub Pages</a>. Photos from <a href="https://unsplash.com" target="_blank" rel="external nofollow noopener">Unsplash</a>. Last updated: December 01, 2025. </div> </footer> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script src="/assets/js/bootstrap.bundle.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@5.0.0/imagesloaded.pkgd.min.js" integrity="sha256-htrLFfZJ6v5udOG+3kNLINIKh2gvoKqwEhHYfTTMICc=" crossorigin="anonymous"></script> <script defer src="/assets/js/masonry.js?a0db7e5d5c70cc3252b3138b0c91dcaf" type="text/javascript"></script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.1.0/dist/medium-zoom.min.js" integrity="sha256-ZgMyDAIYDYGxbcpJcfUnYwNevG/xi9OHKaR/8GK+jWc=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js?85ddb88934d28b74e78031fd54cf8308"></script> <script src="/assets/js/no_defer.js?2781658a0a2b13ed609542042a859126"></script> <script defer src="/assets/js/common.js?c15de51d4bb57887caa2c21988d97279"></script> <script defer src="/assets/js/copy_code.js?c8a01c11a92744d44b093fc3bda915df" type="text/javascript"></script> <script defer src="/assets/js/jupyter_new_tab.js?d9f17b6adc2311cbabd747f4538bb15f"></script> <script async src="https://d1bxh8uas1mnw7.cloudfront.net/assets/embed.js"></script> <script async src="https://badge.dimensions.ai/badge.js"></script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-mml-chtml.js" integrity="sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI=" crossorigin="anonymous"></script> <script src="/assets/js/mathjax-setup.js?a5bb4e6a542c546dd929b24b8b236dfd"></script> <script defer src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6" crossorigin="anonymous"></script> <script defer src="/assets/js/progress-bar.js?2f30e0e6801ea8f5036fa66e1ab0a71a" type="text/javascript"></script> <script src="/assets/js/vanilla-back-to-top.min.js?f40d453793ff4f64e238e420181a1d17"></script> <script>
    addBackToTop();
  </script> <script type="module" src="/assets/js/search/ninja-keys.min.js?a3446f084dcaecc5f75aa1757d087dcf"></script> <ninja-keys hidebreadcrumbs noautoloadmdicons placeholder="Type to start searching"></ninja-keys> <script src="/assets/js/search-setup.js?6c304f7b1992d4b60f7a07956e52f04a"></script> <script src="/assets/js/search-data.js"></script> <script src="/assets/js/shortcut-key.js?6f508d74becd347268a7f822bca7309d"></script> </body> </html>